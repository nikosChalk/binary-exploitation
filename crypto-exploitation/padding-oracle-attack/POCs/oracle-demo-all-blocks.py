

"""
In this demo, we demonstrate a Padding Oracle Attacking, guessing the the plaintext from the ciphertext.
For decrypting the very first block, we also need the IV, which in this demo assume that we have it
"""

import random
from copy import copy
from Crypto.Cipher import AES
from Crypto.Util import Padding

BLOCK_SIZE = 16
KEY = b'0123456789ABCDEF'
IV  = b'\x00'*BLOCK_SIZE
assert(len(KEY) == BLOCK_SIZE)
assert(len(IV) == BLOCK_SIZE)

PLAINTEXT = """Divinity: Original Sin 2 is one of the most beautiful looking isometric RPGs and that hasn't changed.
When most RPGs let you push on and experience almost everything in a single playthrough, it is impossible to experience
all that this one has to offer in one play, or maybe even two or three. The staff of PC Gamer voted it as their game of the year
for 2017, where it was also nominated for the "Best Co-Op Game" award. The staff of GameSpot voted it as their fifth best,
while Eurogamer ranked it 11th on their list of the "Top 50 Games of 2017".
Readers and staff of Game Informer gave it the "Best PC Exclusive", "Best Turn-Based Combat", and "Best Side-Quests" awards,
and also placed it second for the "Best Co-op Multiplayer" award.
The game was also nominated for "Role-Playing Game of the Year" at the D.I.C.E. Awards, for "Game Engineering" and
"Game, Franchise Role Playing" at the NAVGTR Awards, and for "Best Sound Design for an Indie Game" and
"Best Music for an Indie Game" at the Game Audio Network Guild Awards; and won the award for "Multiplayer" at the
14th British Academy Games Awards. It was also nominated for "Music Design" and "Writing or Narrative Design" at the
2018 Develop Awards. The PlayStation 4 and Xbox One versions were nominated for "Best RPG" at the 2018 Game Critics Awards,
and won the award for "Best Role-Playing Game" at Gamescom 2018, whereas its other nomination was for "Best Strategy Game".
"""
PLAINTEXT = bytearray(PLAINTEXT, encoding='utf-8')

def encrypt(plaintext):
    cipher = AES.new(KEY, AES.MODE_CBC, IV)
    return cipher.encrypt(Padding.pad(plaintext, BLOCK_SIZE, style='pkcs7'))

def decrypt(ciphertext):
    cipher = AES.new(KEY, AES.MODE_CBC, IV)
    return Padding.unpad(cipher.decrypt(ciphertext), BLOCK_SIZE, style='pkcs7')

def blockify(buffer):
    return [buffer[i:i+BLOCK_SIZE] for i in range(0, len(buffer), BLOCK_SIZE)]

def printBlokcs(blocks, header=None, footer=None):
    if header is not None:
        print(header)

    block_sizes = [len(block) for block in blocks]
    print('Index i: ' + ''.join(['  %02d ' % i for i in range(0, max(block_sizes))]))
    for i in range(0, len(blocks)):
        block = blocks[i]
        print("Block {}: ".format(i) + ''.join(['0x%02x ' % b for b in block]))
    
    if footer is not None:
        print(footer)


ciphertext = encrypt(PLAINTEXT)
assert(decrypt(ciphertext) == PLAINTEXT)

ciphertext_blocks = blockify(ciphertext)
ciphertext_blocks.insert(0, IV) # Prepend the IV so that we can decrypt the first block without treating it as a special case

printBlokcs(blockify(Padding.pad(PLAINTEXT, BLOCK_SIZE, style='pkcs7')), "\nPadded Plaintext blocks", "")
printBlokcs(ciphertext_blocks, "Ciphertext blocks", "")

print("Attempting decryption of Ciphertext")

decrypted_blocks = [ [0xffffffff for _ in range(BLOCK_SIZE)] for _ in ciphertext_blocks ]

for ctb_idx in range(len(ciphertext_blocks)-1, 0, -1):    #ctb_idx == ciphertext block index
    proccessed_block = [ 0xffffffff for _ in range(BLOCK_SIZE)] # Block which holds the values for the Decrypt(KEY, ciphertext_blocks[ctb_idx])

    for padding in range(1, BLOCK_SIZE+1):
        n = (BLOCK_SIZE-1) - (padding-1)  # index of the first element in the c0_prime block that IS associated with the padding attack
        r = random.randint(1, 255)

        for g in range(0, 256):
            # We remove 0 from the iteration space, sine it is the zero elemenet in the XOR operator, i.e. a^0 = a.
            # We want the first n "irrelevant-random" elements of c0_prime to be different than c0
            # If there are consequtive elements with the same value, we also want them in c0_prime to have different values
            c0_prime = bytearray([ciphertext_blocks[ctb_idx-1][i] ^ (1 + ((r+i) % 255)) for i in range(0, n)])
            c0_prime = c0_prime + bytes([ (ciphertext_blocks[ctb_idx-1][n]   ^ g ^ padding) ])
            c0_prime = c0_prime + bytes([ (ciphertext_blocks[ctb_idx-1][n+i] ^ proccessed_block[n+i] ^ padding) for i in range(1, padding) ])
            c1 = ciphertext_blocks[ctb_idx]
            assert(len(c0_prime) == BLOCK_SIZE)

            try:
                # Here, we do not need to send all the previous ciphertext blocks up until ciphertext_blocks[ctb_idx-2] in order to
                # achieve our attack.
                plaintext_prime = decrypt(c0_prime+c1)
                plaintext_prime_blocks = blockify(plaintext_prime)
                if padding < BLOCK_SIZE:
                    assert(len(plaintext_prime_blocks) == 2)
                elif padding == BLOCK_SIZE:
                    assert(len(plaintext_prime_blocks) == 1)
                else:
                    assert(False and "Unreachable Statement")
            

                # All the decrypted blocks are garbage. We are only interested in the fact that the decryption was successful,
                # i.e. we did not get a padding error. This means that our current guess g satisfies the condition
                # g == plaintext_blocks[ctb_idx][n], i.e. g equals to the Byte#(ctb_idx*BLOCK_SIZE)+n of the plaintext.
                # Note that plaintext_blocks is not the same with plaintext_prime_blocks.
                # plaintext_blocks = blockify(pad(PLAINTEXT))
                proccessed_block[n] = g
                break
            except ValueError as err:
                assert(str(err) == "Padding is incorrect." or str(err) == "PKCS#7 padding is incorrect.")
    print("Successful decryption of block %02d!" % ctb_idx)
    decrypted_blocks[ctb_idx] = proccessed_block

decrypted_blocks = decrypted_blocks[1:] # Discard the first block, which was inserted due to the addition of the IV
printBlokcs(decrypted_blocks, "\nSuccessful decryption of all blocks! Decrypted data are: ", "")
printBlokcs(blockify(Padding.pad(PLAINTEXT, BLOCK_SIZE, style='pkcs7')), "\nExpected blocks", "")

flat_plaintext = b''
for block in decrypted_blocks:
    flat_plaintext += bytearray(block)
flat_plaintext = Padding.unpad(flat_plaintext, BLOCK_SIZE, style='pkcs7').decode('ascii')
print(flat_plaintext)
