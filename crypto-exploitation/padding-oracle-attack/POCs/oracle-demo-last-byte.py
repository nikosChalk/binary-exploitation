

"""
In this demo, we demonstrate a Padding Oracle Attacking, guessing the last Byte of a ciphertext
"""

import random
from copy import copy
from Crypto.Cipher import AES
from Crypto.Util import Padding

BLOCK_SIZE = 16
KEY = b'0123456789ABCDEF'
IV  = b'\x00'*BLOCK_SIZE
assert(len(KEY) == BLOCK_SIZE)
assert(len(IV) == BLOCK_SIZE)

PLAINTEXT = "A message accros 2 blocks" # 25 len < 32 == 2lobkcs
PLAINTEXT = bytearray(PLAINTEXT, encoding='utf-8')

def encrypt(plaintext):
    cipher = AES.new(KEY, AES.MODE_CBC, IV)
    return cipher.encrypt(Padding.pad(plaintext, BLOCK_SIZE, style='pkcs7'))

def decrypt(ciphertext):
    cipher = AES.new(KEY, AES.MODE_CBC, IV)
    return Padding.unpad(cipher.decrypt(ciphertext), BLOCK_SIZE, style='pkcs7')

def blockify(buffer):
    return [buffer[i:i+BLOCK_SIZE] for i in range(0, len(buffer), BLOCK_SIZE)]

def printBlokcs(blocks, header=None, footer=None):
    if header is not None:
        print(header)

    block_sz = len(blocks[0])
    print('Index i: ' + ''.join(['  %02d ' % i for i in range(0, block_sz)]))
    for i in range(0, len(blocks)):
        block = blocks[i]
        print("Block {}: ".format(i) + ''.join(['0x%02x ' % b for b in block]))
    
    if footer is not None:
        print(footer)


ciphertext = encrypt(PLAINTEXT)
assert(decrypt(ciphertext) == PLAINTEXT)
assert(len(ciphertext) == 2*BLOCK_SIZE)

ciphertext_blocks = blockify(ciphertext)
assert(len(ciphertext_blocks) == 2)

printBlokcs(blockify(Padding.pad(PLAINTEXT, BLOCK_SIZE, style='pkcs7')), "\nPadded Plaintext blocks", "")
printBlokcs(ciphertext_blocks, "Ciphertext blocks", "")

print("Attempting decryption of Byte#31")
print(" - Decrypted Byte31: 0x%02x" % Padding.pad(PLAINTEXT, BLOCK_SIZE, style='pkcs7')[-1]) # 0x07 is expected since it is a padding byte
print(" - Encrypted Byte31: 0x%02x" % ciphertext_blocks[1][-1])
print()

r = random.randint(1, 255)
for g in range(0, 256):

    # We remove 0 from the iteration space, sine it is the zero elemenet in the XOR operator, i.e. a^0 = a.
    # We want the first n "irrelevant-random" elements of c0_prime to be different than c0
    # If there are consequtive elements with the same value, we also want them in c0_prime to have different values
    c0_prime = bytearray([ciphertext_blocks[0][i] ^ (1 + ((r+i) % 255)) for i in range(0, BLOCK_SIZE-1)])
    c0_prime = c0_prime + bytes([ ciphertext_blocks[0][-1] ^ g ^ 0x01 ])
    c1 = ciphertext_blocks[1]
    assert(len(c0_prime) == BLOCK_SIZE)

    try:
        plaintext_prime = decrypt(c0_prime+c1)
        plaintext_prime_blocks = blockify(plaintext_prime)
        assert(len(plaintext_prime_blocks) == 2)
        p1_prime = plaintext_prime[1]

        # The decrypted blocks are garbage. We are only interested in the fact that the decryption was successful, i.e. we did not get a padding error
        # This means that our current guess g satisfies the condition g == p[1][15], i.e. g equals to the Byte#31 of the plaintext
        printBlokcs(
            plaintext_prime_blocks,
            "Successful decryption! Decrypted Blocks:",
            "p[1][15] (Byte#31 of plaintext) assumed to be 0x%02x\n" % g
        )
    except ValueError as err:
        assert(str(err) == "Padding is incorrect." or str(err) == "PKCS#7 padding is incorrect.")
