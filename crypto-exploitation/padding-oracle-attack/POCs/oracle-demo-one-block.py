

"""
In this demo, we demonstrate a Padding Oracle Attacking, guessing the last block of a ciphertext
"""

import random
from copy import copy
from Crypto.Cipher import AES
from Crypto.Util import Padding

BLOCK_SIZE = 16
KEY = b'0123456789ABCDEF'
IV  = b'\x00'*BLOCK_SIZE
assert(len(KEY) == BLOCK_SIZE)
assert(len(IV) == BLOCK_SIZE)

PLAINTEXT = "A message accros 2 blocks" # 25 len < 32 == 2lobkcs
PLAINTEXT = bytearray(PLAINTEXT, encoding='utf-8')

def encrypt(plaintext):
    cipher = AES.new(KEY, AES.MODE_CBC, IV)
    return cipher.encrypt(Padding.pad(plaintext, BLOCK_SIZE, style='pkcs7'))

def decrypt(ciphertext):
    cipher = AES.new(KEY, AES.MODE_CBC, IV)
    return Padding.unpad(cipher.decrypt(ciphertext), BLOCK_SIZE, style='pkcs7')

def blockify(buffer):
    return [buffer[i:i+BLOCK_SIZE] for i in range(0, len(buffer), BLOCK_SIZE)]

def printBlokcs(blocks, header=None, footer=None):
    if header is not None:
        print(header)

    block_sizes = [len(block) for block in blocks]
    print('Index i: ' + ''.join(['  %02d ' % i for i in range(0, max(block_sizes))]))
    for i in range(0, len(blocks)):
        block = blocks[i]
        print("Block {}: ".format(i) + ''.join(['0x%02x ' % b for b in block]))
    
    if footer is not None:
        print(footer)


ciphertext = encrypt(PLAINTEXT)
assert(decrypt(ciphertext) == PLAINTEXT)
assert(len(ciphertext) == 2*BLOCK_SIZE)

ciphertext_blocks = blockify(ciphertext)
assert(len(ciphertext_blocks) == 2)

printBlokcs(blockify(Padding.pad(PLAINTEXT, BLOCK_SIZE, style='pkcs7')), "\nPadded Plaintext blocks", "")
printBlokcs(ciphertext_blocks, "Ciphertext blocks", "")

print("Attempting decryption of Block#1 (last block)")

decrypted_last_block = [ 0xffffffff for _ in range(BLOCK_SIZE)]
for padding in range(1, BLOCK_SIZE+1):
    n = (BLOCK_SIZE-1) - (padding-1)  # index of the first element in the c0_prime block that IS associated with the padding attack
    r = random.randint(1, 255)

    for g in range(0, 256):
        # We remove 0 from the iteration space, sine it is the zero elemenet in the XOR operator, i.e. a^0 = a.
        # We want the first n "irrelevant-random" elements of c0_prime to be different than c0
        # If there are consequtive elements with the same value, we also want them in c0_prime to have different values
        c0_prime = bytearray([ciphertext_blocks[0][i] ^ (1 + ((r+i) % 255)) for i in range(0, n)])
        c0_prime = c0_prime + bytes([ (ciphertext_blocks[0][n]   ^ g ^ padding) ])
        c0_prime = c0_prime + bytes([ (ciphertext_blocks[0][n+i] ^ decrypted_last_block[n+i] ^ padding) for i in range(1, padding) ])
        c1 = ciphertext_blocks[1]
        assert(len(c0_prime) == BLOCK_SIZE)

        try:
            plaintext_prime = decrypt(c0_prime+c1)
            plaintext_prime_blocks = blockify(plaintext_prime)
            if padding < BLOCK_SIZE:
                assert(len(plaintext_prime_blocks) == 2)
            elif padding == BLOCK_SIZE:
                assert(len(plaintext_prime_blocks) == 1)
            else:
                assert(False and "Unreachable Statement")
            

            # All the decrypted blocks are garbage. We are only interested in the fact that the decryption was successful,
            # i.e. we did not get a padding error. This means that our current guess g satisfies the condition
            # g == p[1][n], i.e. g equals to the Byte#16+n of the plaintext
            print("Successful decryption at index %02d!" % n)
            print("  - p[1][%02d] (Byte#%2d of plaintext) assumed to be 0x%02x" % (n, (16+n), g))
            decrypted_last_block[n] = g
            break
        except ValueError as err:
            assert(str(err) == "Padding is incorrect." or str(err) == "PKCS#7 padding is incorrect.")

printBlokcs([[], decrypted_last_block], "\nSuccessful decryption of last block! Decrypted data are: ", "")

printBlokcs(blockify(Padding.pad(PLAINTEXT, BLOCK_SIZE, style='pkcs7')), "\nExpected blocks", "")
