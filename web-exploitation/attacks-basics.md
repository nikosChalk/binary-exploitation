# Web Basics

## Cross Site Scripting (XSS)

Cross-Site Scripting (XSS) attacks are a type of injection, in which malicious scripts are injected into otherwise benign and trusted websites. Flaws that allow these attacks to succeed occur anywhere a web application uses input from a user within the output it generates without validating or encoding it.

### Reflected XSS

What we send as user input to the server through a request, is included in the response that the server sends back to us.

<a href="assets/reflected-xss.mp4" target="_blank"><img src="assets/reflected-xss-thumbnail.png" alt="Reflected XSS in 10 secs" width="400" /></a>

### XSS Useful resources

* [XSS Filter Bypass Cheat Sheet](https://owasp.org/www-community/xss-filter-evasion-cheatsheet)
  * If no quotes of any kind are allowed you can use `eval()` and `fromCharCode()`. e.g.:<br/>
  `eval(String.fromCharCode(106,97,118,97,115,99,114,105,112,116,58,97,108,101,114,116,40,34,88,83,83,34,41));`<br/>
  which is equivalent to <br/>
  `javascript:alert("XSS");`
* [XSS Prevention techniques](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#xss-prevention-rules) for the developer

### Stored XSS

In this case, the malicious JavaScript is stored at the server side, e.g. in a database. In subsequent requests, the malicious JavaScript is also included in the response. (e.g. A comment on a blog post managed to include malicious JavaScript)

## Confused Deputy Attacks

A confused deputy is a legitimate, more privileged computer program that is tricked by another program into misusing its authority on the system. It is a specific type of privilege escalation.

### Cross Site Request Forgery (CSRF)

In this case, the confused deputy is the browser. We have a malicious page M and when the browser visits it, we send a request to a different site S in which the user is logged in. The browser automatically adds any cookies in the request towards S, allowing us to execute privileged actions on behalf of the user.

In a nutshell <br/>
<img src="assets/csrf-nutshell.png" alt="csrf-nutshell" width="600px"/>

Notes:

* In the scenario above we used a `GET` request to modify data on the server which is not realistic. But we can also use `POST` requests with the payload of our liking. We use auto-submitting form as seen from the example bellow
  ```html
  <!-- Code hosted on evil.com, waiting for a user to visit this website -->
  <form action="http://bank.com/transfer" method="POST" id="evilform">
    <input type="hidden" name="amount" value="10000"/>
    <input type="hidden" name="dest" value="6176166152722"/>
  </form>
  <script>
    //Auto-submit form without user input
    document.getElementById('evilform').submit(); 
  </script>
  ```
* You might also have to explicitly set the `Content-Type` header when performing your request to the correct one. Because the vulnerable server might be waiting for JSON, forms, XML, etc. Otherwise your request might be ignored.
* SOP does not block the request. The request is sent to the server and only the response is blocked.
<img src="assets/sop-csrf.png" alt="sop-and-csrf" width="512px"/>
* If we have XSS on one site, we can redirect the user to our malicious site in order to perform the privileged action on another site that he is logged in.
* ***If we have XSS on the same site, the attack becomes even more powerful. We can bypass the SOP and even read the response. So we also have information disclosure.***

### Server Side Request Forgery (SSRF)

In this case, the confused deputy is a server. The attacker makes the vulnerable server A to send a request to another server B and return the results back to the client (attacker). In typical SSRF examples, the attacker might cause the server to make a connection back to itself (`127.0.0.1`, `localhost`, etc.), or to other web-based services within the organization's infrastructure, or to external third-party systems.

SSRF attacks often exploit trust relationships between servers to escalate privileges.

* localhost is used to access an admin panel like `https://localhost/admin` for example or other services that are only exposed locally (e.g. a database).

## Session Prediction Attack

The [session prediction attack](https://owasp.org/www-community/attacks/Session_Prediction) focuses on predicting session ID values that permit an attacker to bypass the authentication schema of an application. By analyzing and understanding the session ID generation process, an attacker can predict a valid session ID value and get access to the application or impersonate another user (e.g. admin)

* After a use logins, a new session must be issued to avoid session fixation attacks

![session-management](https://cheatsheetseries.owasp.org/assets/Session_Management_Cheat_Sheet_Diagram.png)

See Natas level19 for an example of Session Prediction

## Path Traversal

The Path Traversal attack technique allows an attacker access to files, directories, and commands that potentially reside outside the web document root directory. An attacker may manipulate a URL in such a way that the web site will execute or reveal the contents of arbitrary files anywhere on the web server.

e.g. `https://natas7.natas.labs.overthewire.org/index.php?page=/etc/passwd`

Most web servers restrict user access to a specific portion of the file-system, typically called the "***web document root***" or "***CGI root***" directory. These directories contain the files intended for user access and the executables necessary to drive web application functionality.

Usual characters used for Path Traversal are

* `../` (Usually escaped)
* valid and invalid Unicode-encoding (`..%u2216` or `..%c0%af`) of the `/` character
* URL encoded characters `%2e%2e%2f`
* Double URL encoding `..%255c`
* See [a Path Traversal Cheatsheet](https://gracefulsecurity.com/path-traversal-cheat-sheet-linux/) for more

Dot character *`.`* can be used for listing the files of a directory and `%00` to represent the NULL character.

Even if the web server properly restricts Path Traversal attempts in the URL path, a web application itself may still be vulnerable due to improper handling of user-supplied input.

## Local File Inclusion (LFI) attacks

Local File Inclusion (LFI) allows an attacker to dump server files or execute files server-side. This vulnerability exists when a web application uses user input to include a file and does improper (or no) sanitization.

### Example of vulnerable PHP code to LFI attacks

```php
if(array_key_exists("file", $_REQUEST))
  include($_REQUEST["file"]);
else
  include("default.php");
```

Some examples of GET requests that can exploit this bug and dump arbitrary files are:

* `GET /index.php?file=../../../../etc/passwd` (Number of back directories (`../`) depend on the server )
* `GET /index.php?file=/etc/passwd`
* `GET /index.php?file=/proc/self/environ`
* `GET /index.php?file=/var/log/apache2/access.log`
* `GET /index.php?file=/var/log/apache2/log-with-malicious-PHP-code.log`
  * The malicious PHP code can be entered by the user with a previous HTTP request. Usually it is present in the headers

We can also use various [PHP Wrapper modules](https://www.php.net/manual/en/wrappers.php.php) to achieve more than just file dumping, like executing commands. Various PHP Wrappers used for the LFI purpose are:

* [OWASP Local File Inclusion](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/11.1-Testing_for_Local_File_Inclusion) from OWASP
* [LFI Cheat Sheet](https://highon.coffee/blog/lfi-cheat-sheet/) From HighOn.Coffee
* [PayloadsAllTheThings - LFI Cheat Sheet](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion) From the GitHub repository "PayloadsAllTheThings"
