list-style-type:lower-roman;

# Takeaways

## General
1. Remember from stack5 challenge that environment variables and program arguments affect stack addresses. The reason is that they exist bellow the first stack frame.
2. The method here to trigger the bug is worth noting.
    - First, we have a constant input string of 1000 characters because the length of the program arguments affect the offset of the addresses.
    - We use quotes around the python output because the output contains whitespaces. If we didn't use quotes, the output was interpreted as multiple program arguments.
3. Below are some format parameters which can be used and their consequences:
    - `%x` or `%p` Read data from the stack. For example:
        - `0x%08x` (`unsigned int` as hex prefixed with "0x" with at least 8 characters. Zero-padded if necessery)
        - `%p` (`void*` as hex, also prefixed with 0x if non-zero)
    - `%s` Read character strings from the process’ memory
    - `%n` Write an integer to locations in the process’ memory
4. The maximum value that we could write with `%n` was `0x3affffff`, which is actually the total number of characters that we were able to print. They were generated with `%989855743d` (989855743<sub>10</sub> == 0x3affffff) and were whitespaces. The printing took about 1 minutes and 30 seconds. Larger values were generating a Segmentation fault (see quote bellow).<br/>
We also managed to print `0x3b2bfd9f` characters, but sometimes we were getting a Segmentation Fault due to the large string. <br/>
Quoting the man page of `printf` from the `BUGS` section:
> Because sprintf() and vsprintf() assume an arbitrarily long string, callers must be careful not to overflow the actual space; this is often impossible to assure. Note that the length of the strings produced is locale-dependent and difficult to predict.




## Now lets observer the <u>solution<span>.</span>py</u>:
1. We see that we wrap the target address `0x08049638` around 8 `A` and 8 `B` characters. The reason we do that is that when we examine memory with `%x`, we make it easier to locate the target address as it *will look like* (but may not exactly be) `0x41414141 0x41414141 0x08049638 0x42424242 0x42424242`.
2. We say that it *will look like* due to alignment issues. We use the `%x` to examine memory content. We start dumping the stack. However, our target address may be at offset `x` or `x+1` or `x+2`, etc. This depends on:
    1. The program argument length
        - When the length increases, stack addresses are moved "upwards", i.e. to smaller addresses. Example with 1001 characters: <br/>
        `0x41003174 0x41414141 0x38414141 0x42080496`
    2. The offset within the string that the target address is located. 
        - Adding a single space before the start, forces us to print 1 more hex value in order to find it mis-aligned
            ```python
            " AAAA" + "AAAA" + target_addr + "BBBB" + "BBBB" + "%x "*119 + "%x %x"
            > 0x41414120 0x41414141 0x4963841 0x42424208
            ```
        - Note that only characters *before* the target address affect its offset. Not after.<br/><br/>
        <b>So</b>, in order to fix mis-alignment issues, add a few spaces before your target address in order for the `%x` to find it aligned. Keep the same string length.
3. Something else to note is the number of `%x` the we use (e.g. 125 or 119 as seen in the source code). This is some trial and error in order to find our program argument string in the memory. While fiddling around with this number you may come across a pattern, e.g. `20782520 25207825 78252078 20782520 25207825`. If you decode this in ascii with:
    ```python
    "2078252025207825782520782078252025207825".decode("hex")
    ```
    you get ` x% % x%x% x x% % x%`, which is our input string! (with some alignment issues).<br/>
    This pattern is a nice way to locate our string in the chaotic hex output
4. In the python solution<span>.</span>py you will notice in line 15 that we have `%x` and in line 16 we change it in `%n`. That is because we use the last specifier in order to find our target address, and when we do that, we change the specifier in order to instead write to that target address.
5. The second solution (`payload2`) found in the python file, stems from the first solution (`payload1`) and is a more compact one.

