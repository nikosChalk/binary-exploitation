

# Takeaways

In this level we exploit a simple buffer overflow to perform ret2libc. This challenge differs from the rest since this is our <i>first remote buffer overflow</i> exploit.

## How to debug remote binary exploitation challenges

In the protostar machine, in its [description](https://old.liveoverflow.com/binary_hacking/protostar/index.html), it states that:

> The `/proc/sys/kernel/core_pattern` is set to `/tmp/core.%s.%e.%p`. This means that instead of the general `./core` file you get, it will be in a different directory and different file name.

So, core dump files will have the pattern: `/tmp/core.<signal_num>.<executable_name>.<PID>` as described in the [man page of core](http://man7.org/linux/man-pages/man5/core.5.html). Also there it describes what a core dump file is:

> <i><u>core - core dump files</u></i>. The default action of certain signals is to cause a process to terminate and produce a core dump file, a disk file containing an image of the process's memory at the time of termination. This image can be used in a debugger (e.g., gdb(1)) to inspect the state of the program at the time that it terminated. A list of the signals which cause a process to dump core can be found in signal(7).

We can inspect the core dump file with `gdb <program> <core>`, e.g.</br>
`$ gdb /opt/protostar/bin/final0 /tmp/core.11.final0.6134`

We can also attach to the already running instance of `final0` by running:<br/>
`$ gdb -p $(pidof final0)`<br/>
and then make GDB to also debug child processes:<br/>
`(gdb) set follow-fork-mode child`

In case that you want to test the exploit locally, you can:
`print(payload)`, where `payload` is the payload that we construct remotely, and the result should be something like `bytearray(b'\x00AAA...AAA\xb0\xff\xec\xb7BBBB\xbfc\xfb\xb7\n')`. Then, create the following <span>solution.py</span> in the remote machine

```python
print(bytearray(b'\x00AAA...AAA\xb0\xff\xec\xb7BBBB\xbfc\xfb\xb7\n'))
```

and just run the vulnerable program locally with this payload as input.
