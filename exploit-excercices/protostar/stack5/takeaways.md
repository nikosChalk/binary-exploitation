# Takeaways
Here are some conclusions that can be drawn from this challenge and represent a few struggles that occurred

1. If a program calls a function from the `exec`family (e.g. `execv`), then we have to reload the program in GDB if we want to re-run it again. This is done with `file a.out`
2. Environment variables and program arguments affect stack addresses because they are stored in the stack area! The operating system loader places both <b>environment variables</b> and <b>program arguments</b> <i>before</i> the beginning of the first stack frame. <br/>
For example, if we execute the same program from a different directory (thus a different `PWD` environment variable) we will notice that values on the stack are not on the same address. This is because different paths have different length and thus take up different space on the stack.
    * The same goes if we run a program locally or over SHH
    * <u>The same is true for GDB!</u>
    * The same is true for the way that we invoke a program, e.g. `./foo` vs `/home/user/foo` as the name of the program is part of the program arguments
    * The following two ways of un-setting the environment have a <b><u>different result</u></b> on stack addresses!
        ```
        env - gdb /opt/protostar/bin/stack5
        (gdb) unset env
        ``` 
        ```
        gdb /opt/protostar/bin/stack5
        (gdb) unset env
        ```
        <b>The correct one to <u>use</u> is <u>the first</u></b>.
    * What you may encounter as hint to indicate this problem is a working payload in GDB, but Illegal Instruction or Segmentation Fault during normal execution of the binary.
    * Mitigations
        1. We can start the process without environment variables.<br/> `$ env -i ./a.out` or in gdb `(gdb) unset env`<br/>
        2. We can also use a `nop` slide to increase our chances of hitting our code
3. When we managed to execute bash with our shellcode, it did seemd like nothing happened. What was happening is that we were redirecting the output of a process to our newly created bash. However, the process had exited, thus closed its stdout descriptor. So bash, which had as stdin the output of the closed process, also closed.
4. At first, with our custom exploit we were getting only user shell, not root. That is because we were executing /bin/bash instead of /bin/dash or /bin/sh. Bash drops privileges when executed. See more info here https://stackoverflow.com/questions/46778979/why-will-my-buffer-overflow-exploit-open-a-user-shell-only-instead-of-a-root-she
5. `struct.pack()` has a different meaning in our machine than in the target one. So don't be surprised in case of different outputs!
