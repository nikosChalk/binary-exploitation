

# Takeaways
In this solution, instead of writing one big 4-Byte value at a specific address, we split the value into two inherently smaller 2-Byte values and perform two write operations instead.<br/>

## Advantages
1. We can write any arbitrary value with arbitrary length in Bytes (This method can also be used to write 5,6,7,8,... Bytes)
2. Execution speed is much faster than solution1
3. This method is more reliable to not overflow the address space with big `printf`, as mentioned in the takeaways of format1


## Disadvantages 
1. <b><u>In this method we also destroy 2 Bytes from the GOT table.</u></b>
    - Depending on the binary, these could be saved with a more careful write
2. Requires memory access to the next 2 Bytes that are after our target address (i.e. not to cause segmentation fault by writing there)

## Notes

1. Order of write operations matters because values are written as "int", i.e. 32bit values, and thus can overlap.
2. The second write must always write a bigger number than the first write. This is because the 2<sup>nd</sup> `%n` specifier cannot write a value less than the value written by the 1<sup>st</sup> `%n` specifier.

We will perform 2 writes:
1.  We will first write the lower half Bytes of the number. These correspond to the bytes at addresses `0x8049724` and `0x8049725` of the 4-Byte word located at address `0x8049724`. This is because we are in Little Endian. The rest of the bytes will be garbage
    - We will achieve our result by writing a word at address `0x8049724`
2. Then, we will write the higher half Bytes of the number. These correspond to `0x8049726` and `0x8049727` of the 4-Byte word located at address `0x8049724`. The rest of the bytes will be garbage.
    - We will achieve our result by writing a word at address `0x8049726`

```C
  //Hex    : 0x080484B4
  //Stored in Little Endian:
  //        [ 0xB4 ] [ 0x84 ] [ 0x04 ] [ 0x08 ] 
  //0x8049724: 0xB4
  //0x8049725: 0x84
  //0x8049726: 0x04
  //0x8049727: 0x08
  //0x8049728: 0x??
  //0x8049729: 0x??

  We will perform 2 int writes (Each one 4 Bytes).
    - First at address 0x8049724                , with value 0x000084B4
    - Then  at address 0x8049726 == 0x8049724+2 , with value 0x00010804
  Our goal is for the address 0x8049724 to contain the value 0x080484B4

  Offset from 0x8049724:
               0        1        2        3        4        5
  Write 1: [ 0xB4 ] [ 0x84 ] [ 0x00 ] [ 0x00 ] [      ] [      ] 
  Write 2: [      ] [      ] [ 0x04 ] [ 0x08 ] [ 0x01 ] [ 0x00 ] 
  Result:  [ 0xB4 ] [ 0x84 ] [ 0x04 ] [ 0x08 ] [ 0x01 ] [ 0x00 ] 
```
