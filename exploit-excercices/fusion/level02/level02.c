
#include "../common/common.c"    

#define XORSZ 32

void cipher(unsigned char *blah, size_t len)
{
  static int keyed;
  static unsigned int keybuf[XORSZ];

  int blocks;
  unsigned int *blahi, j;

  if(keyed == 0) {
      int fd;
      fd = open("/dev/urandom", O_RDONLY);
      if(read(fd, &keybuf, sizeof(keybuf)) != sizeof(keybuf)) exit(EXIT_FAILURE);
      close(fd);
      keyed = 1;
  }

  blahi = (unsigned int *)(blah);
  blocks = (len / 4);
  if(len & 3) blocks += 1;

  for(j = 0; j < blocks; j++) {
      blahi[j] ^= keybuf[j % XORSZ];
  }
}



// Before returning fronm encrypt_file()
// (gdb) p $esp
// $20 = (void *) 0xbf9a9b00
// (gdb) p $ebp
// $21 = (void *) 0xbf9c9b28
// (gdb) p &op
// $13 = (unsigned char *) 0xbf9a9b1b "E", 'A' <repeats 199 times>...
// (gdb) p &buffer
// $14 = (unsigned char (*)[131072]) [0xbf9a9b1c, 0xbf9c9b1c)
// (gdb) p &sz
// $15 = (size_t *) 0xbf9a9b14
// (gdb) p &loop
// $16 = (int *) 0xbf9c9b1c
// (gdb) c
// Continuing.

// Program received signal SIGSEGV, Segmentation fault.
// 0x44444444 in ?? ()
// (gdb) info registers
// eax            0x51     81                       <--- Value corresponds to 'Q'
// ecx            0xbf9a9b1b       -1080386789      <--- &op
// edx            0x1      1
// ebx            0xb772cff4       -1217212428
// esp            0xbf9c9b30       0xbf9c9b30       <--- stack address
// ebp            0x43434343       0x43434343
// esi            0x0      0
// edi            0x0      0
// eip            0x44444444       0x44444444
// eflags         0x10246  [ PF ZF IF RF ]
// cs             0x73     115
// ss             0x7b     123
// ds             0x7b     123
// es             0x7b     123
// fs             0x0      0
// gs             0x33     51

void encrypt_file()
{
  // http://thedailywtf.com/Articles/Extensible-XML.aspx
  // maybe make bigger for inevitable xml-in-xml-in-xml ?

  //buffer == $ebp-131084
  unsigned char buffer[32 * 4096 /* == 131072 */ ];

  unsigned char op;
  size_t sz;
  int loop;

  printf("[-- Enterprise configuration file encryption service --]\n");
  
  loop = 1;
  while(loop) {
      nread(0, &op, sizeof(op));
      switch(op) {
          case 'E':
              nread(0, &sz, sizeof(sz));
              nread(0, buffer, sz);
              cipher(buffer, sz);
              printf("[-- encryption complete. please mention "
              "474bd3ad-c65b-47ab-b041-602047ab8792 to support "
              "staff to retrieve your file --]\n");
              nwrite(1, &sz, sizeof(sz));
              nwrite(1, buffer, sz);
              break;
          case 'Q':
              loop = 0;
              break;
          default:
              exit(EXIT_FAILURE);
      }
  }
      
}

int main(int argc, char **argv, char **envp)
{
  int fd;
  char *p;

  background_process(NAME, UID, GID); 
  fd = serve_forever(PORT);
  set_io(fd);

  encrypt_file();
}
