

#include "../common/common.c"    


// Note that since ASLR is enabled for heap,stack, and dynamic libraries, the bellow addresses are taken from a sample run.
// .text section does note have ASLR, thus we can use it to search for gadgets

// 0x43434343 in ?? ()
// (gdb) info registers
// eax            0x1      1
// ecx            0xb75b78d0       -1218742064
// edx            0xbf9a3804       -1080412156
// ebx            0xb772fff4       -1217200140
// esp            0xbf9a3800       0xbf9a3800   <---- == edge of parse_http_request() stack frame, when fix_path() has been invoked. We control the content through buffer overflow
// ebp            0x42424242       0x42424242   <---- value controlled by us
// esi            0xbf9a38b9       -1080411975  <---- Points within buffer. == buffer+161 == start of shellcode
// edi            0x8049ed1        134520529
// eip            0x43434343       0x43434343   <--- value controlled by us
// eflags         0x246    [ PF ZF IF ]
// cs             0x73     115
// ss             0x7b     123
// ds             0x7b     123
// es             0x7b     123
// fs             0x0      0
// gs             0x33     51


// ~~~ fix_path() ~~~
//[0xbf9a3770, 0xbf9a37f0): resolved

// ~~~ parse_http_request() ~~~
//[0xbf9a3818, 0xbf9a3c18) : buffer
//0xbf9a3c1c: path
//0xbf9a3c18: q

int fix_path(char *path)
{

  //Stack frame size: 0x98 == 152 Bytes 
  //Stack frame including old ebp and return address: 160 Bytes
  //
  //esp
  //esp+0x10 == resolved

  char resolved[128];
  
  //Even if the path is invalid, and we get "No such file or directory\n", when invoking perror(""),
  //realpath will still copy path to resolved. Thus we can do a buffer overflow.
  //We can also get the value of errno with (gdb) p *__errno_location()
  //
  //realpath will also write a '\x00' at the end of path, so mind that too.
  if(realpath(path, resolved) == NULL) return 1; // can't access path. will error trying to open
  strcpy(path, resolved);
}

char *parse_http_request()
{
  char buffer[1024];
  char *path;
  char *q;

  // printf("[debug] buffer is at 0x%08x :-)\n", buffer); :D

  if(read(0, buffer, sizeof(buffer)) <= 0) errx(0, "Failed to read from remote host");
  if(memcmp(buffer, "GET ", 4) != 0) errx(0, "Not a GET request");

  path = &buffer[4];
  q = strchr(path, ' ');
  if(! q) errx(0, "No protocol version specified");
  *q++ = 0;
  if(strncmp(q, "HTTP/1.1", 8) != 0) errx(0, "Invalid protocol");

  fix_path(path);

  printf("trying to access %s\n", path);

  return path;
}

int main(int argc, char **argv, char **envp)
{
  int fd;
  char *p;

  background_process(NAME, UID, GID); 
  fd = serve_forever(PORT);
  set_io(fd);

  parse_http_request(); 
}
