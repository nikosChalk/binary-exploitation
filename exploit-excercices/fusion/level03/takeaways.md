# Takeaways

This was a very challenging level, in the way that we could not have any feedback through any of the stdout, stderr, stdin, or the opened connection. We utilized unused `.bss` address space to store our results (e.g. leaked addresses) and used it as a scratch area to perform operations with registers. In order to leak a libc address we constructed a write primitive and used it to copy a <u>resolved</u> libc entry from the `.got.plt` section to an unused memory area within the `.bss` section. In order to invoke the write primitive, we used function stubs available within the `.plt` section since ASLR was enabled. Furthermore, we chained lots of gadgets and function calls. Finally the write primitive that we constructed was used repeatedly.

## Solution not working

It really matters to have a heavily populated environment before starting the `level03`. This pushes the stack upwards giving our exploit more room to overflow with gadgets, before reaching the end of the stack page. More specifically, `level03` should be run by the `root` user for our exploit to work and not by the system's `init` process.

For example, when we have a heavily populated environment (`printenv` command to view it), the `title` buffer starts at address `0xbfe26d2c` and the stack ends at `0xbfe29000`. This gives us `0x22d4 == 8916` Bytes to write and our payload is `3982` Bytes long. Good enough!

However, when the `level03` binary was started by the `init` process during boot time of the system, the `title` buffer was located at address `0xbfe28bec` giving us only `0x414 == 1044` Bytes to write our payload. These are not enough and when `decode_string()` attempts to write at address `0xbfe29000`, the program will crash.

## Alternative solution

A solution that would be more space-wise efficient could leak libc addresses through `post_blog_article()`. One address can be leaked per connection made. Thus after gathering the required libc addresses, the script can be shortened. However, this still does not eradicate the tons of `memcpy()` function calls that we issue.

In case that you are wondering what happens with ASLR when a forks occur, the memory mapping of the child and parent are the same after the fork. They only start to diverge when `mmap(NULL, ...)` is invoked. ([Source](https://stackoverflow.com/questions/8171298/is-address-space-layout-randomization-applied-on-a-forked-process/8171410#8171410))

## Other attempts

We tried to leak heap addresses but the effort was futile. I could not find any gadget combination that would allow me set the value of a known address (e.g. in `.bss` section) to a heap address in order to leak it. However, we only searched for gadgets in the non-ASLR area (Addresses `0x8048000 - 0x804c000`). If we followed the above alternative solution, we could also search for gadgets in the dynamic libraries that the binary loads, namely in `libc`, `libz`, `libdl`, `libcrypto`, `libjson` and `ld`.

In case that a heap address was leaked, our `command` argument in `system()` can be placed within the blog (e.g. in the `conents` field) and thus we can remove all those `memcpy()` calls, fitting our exploit within the original stack limits.

## Conclusion

Due to the limitation of not having a file descriptor to write stuff, this challenge took some time to solve. We did not try the above alternative solution because a lot of time was already poured in this challenge. However we learned a lot of stuff such as what is ASLRed (heap, dynamic libraries, stack), creating a write primitive, chaining multiple function calls through gadgets.
