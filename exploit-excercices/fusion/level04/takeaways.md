# Takeaways

In this level we had to overcome a lot of mitigations. We managed to perform the following accomplishments:

1. We pulled our first timing attack against a secret password that is generated on the server. This password was part of the "Basic" HTTP authentication scheme.
    * For the authentication scheme, see mozilla's documents [[1](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization)] [[2](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#Basic_authentication_scheme)]
2. We brute-forced a stack canary, overcoming source code fortification (`-fstack-protector` gcc flag)
    * `-fstack-protector`: To save execution time, GCC uses simple heuristic with -`fstack-protector` flag: add canaries for functions that use `alloca` or local buffers larger than 8 bytes (by default). The heuristic can be tweaked with `ssp-buffer-size` parameter.
3. All pages of the process were placed in random addresses due to ASLR and PIE. We managed to overcome this mitigation by brute-forcing `ebx` register which has a critical role in PIE-enabled binaries.
4. Using decompiled code generated by Ghidra, we observed that the generated machine code differs from the original source code. This is due to optimizations and fortification.  
5. Finally, as a side project we learned to use generators in python and the `yield`. See more [here](https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do/231855#231855)

Most these points will be discussed in detail further bellow and also a roadmap of the level04 challenge will be given.

## Timing attack

The timing attack was used in order to overcome the authorization in the web server. On each tried password we observed the response from the server. When presented a wrong password, the server would delay `2500*bytes_wrong` microseconds, while, when presented the correct password, the server would not delay.

The most accurate pattern to measure time in python is the following:

```python
conn = remote(ip, port)

# Create an epoll object to monitor for responses after the send operation
# The object is edge-triggered
epoll = select.epoll()
epoll.register(conn.sock.fileno(), select.EPOLLIN | select.EPOLLPRI | select.EPOLLET)

# Send data to the server
conn.send(request) # request is a bytes-like object

start = time.perf_counter()
events = epoll.poll()   # blocking
end = time.perf_counter()
for fileno, _ in events:
    assert(fileno == conn.sock.fileno())

# [Optional]
# Due to epoll, we know that data are available. Receive the data
d = conn.recv()

# Calculate time-difference
usec_elapsed = (end - start)*1000*1000
if usec_elapsed < threshold:
    log.info('Server responded fast')
else:
    log.info('Server responded slower than usual')
```

1. For general information about epoll, see [man 4 epoll](https://linux.die.net/man/4/epoll) and [man 7 epoll](https://man7.org/linux/man-pages/man7/epoll.7.html)
2. For the `binary OR` (`|`) mask values that are available see the [python documentation](https://docs.python.org/3.6/library/select.html#edge-and-level-trigger-polling-epoll-objects) and [man 2 epoll_ctl](https://man7.org/linux/man-pages/man2/epoll_ctl.2.html) for a more in-depth explanation
3. We prefer `time.perf_counter()` ([see documentation](https://docs.python.org/3.6/library/time.html#time.perf_counter)) over `time.time()` because the value comes from a performance counter, i.e. a clock with the highest available resolution to measure a short duration. It does include time elapsed during sleep and is system-wide, which a requirement since during `epoll.poll()` we are actually suspended as a process from the system.
    * This is also the reason that we avoid using `time.process_time()`, because it does not measure time elapsed during sleep, and, during `epoll.poll()` we actually sleep until woken by the OS.
4. We poll instead of reading data, so that we do not also measure the time to read and parse the sent data. Keep in mind that the server might respond with a different response on a correct and on a wrong password, thus yielding different reading and parsing times.
5. We used warm up samples in this level (code `for pwChar in itertools.chain('@'*warmups, generator):`). The results from these samples are discarded and they are used in order to set up the CPU's cache, reducing any deviations in the measured time.
6. We use `epoll()` over `poll()` because `epoll()` is newer than `poll()` and faster than `select()`. See more [here](https://stackoverflow.com/questions/17355593/why-is-epoll-faster-than-select) 

## Stack-canary brute-forcing

In this level we brute-forced the stack canary. As expected brute-forcing a 32-bit value takes 2<sup>32</sup> tries (Imagine that on 64bits!), which is not possible to brute-force in realistic time. The stack canary is 32 bits, i.e. 4 Bytes in 32bit system. So, we overwrite 1 Byte on each try (i.e. brute-forcing 1 Byte and leaving the rest intact) and then check for any stack-smashing error messages from the server. Thus we perform at most `256*4 == 1024` different tries.

## `ebx` register brute-forcing

Since the binary has ASLR and is PIE-enabled, even if we control the return address, we have nowhere to jump without any address leak. In 32bit binaries, as explained in the [pie.md](pie.md) document, the `ebx` register is stored on the stack and holds the address of the GOT table. We utilise the same brute-force technique in order to leak the value of `ebx`.

Once we have leaked the `ebx`, we can calculate the base address of the binary and find which functions are available within the `.plt` section. We can invoke these to create leak or write primitives.

In another scenario, we could have leaked the value of `ebx` register using a leak primitive and then restore its value when necessery through `pop ebx` gadgets.

## level04 roadmap

1. Find a buffer overflow vulnerability. Found in `validate_credentials()`
2. Bypass the password authentication mechanism so that `validate_credentials()` returns
3. Exploit the buffer overflow so that the program crashes.
    1. Calculate the offsets for the stack canary, `ebx` register, and the return address in the stack frame of `validate_credentials()`
4. Brute-force the stack canary
5. Brute-force the value of the `ebx` register.
    * Now we have leaked an address the belongs to the pages of the `level04` binary thus we calculate its base address.
    * Now we also know where the `.got.plt` section resides
6. We construct a leak primitive in order to leak libc addresses
    * We utilize functions available in the `.plt` section in order to perform the leak. We use resolved addresses in the `.got.plt` section in order to leak more libraries.
7. We leak the address of a function in libc
    * We repeat this step as many times as necessary in order to find the version of libc using the [libc-database](https://github.com/niklasb/libc-database) tool
    * Now we have the base address of the libc. Thus we can calculate the offset to `system()` and `"/bin/sh"`
8. Using the buffer overflow, and the leaked addresses, invoke `system("/bin/sh")`
    * The system has now been pwned!

Finally, even if the binary had Full-RELO (Read Only relocations) enabled, then we could still pwn the system since we do not overwrite any GOT entries.
