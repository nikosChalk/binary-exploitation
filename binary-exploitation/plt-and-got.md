

# General

## `ldd` tool
`ldd`  prints  the  shared  libraries required by each program or shared library specified on the command line. For example, running `ldd ./format4` gives us output:
```
linux-gate.so.1 =>  (0xb7fe4000)
libc.so.6 => /lib/libc.so.6 (0xb7e99000)
/lib/ld-linux.so.2 (0xb7fe5000)
```
This tells us for example that libc is loaded at address `0xb7e99000`. Running multiple times this command will tell us if ASLR is enabled, because if it is enabled we will get different addresses each time.


## <i>Relocations</i>
<i>Relocations</i> are entries in binaries that are left to be filled in later -- at link time by the toolchain linker or at runtime by the dynamic linker. A <i>relocation</i> in a binary is a descriptor which essentially says "determine the value of X, and put that value into the binary at offset Y". <br/>
Each relocation has a specific type, defined in the ABI documentation, which describes exactly how "determine the value of" is actually determined. <br/>
Running `readelf -r ./format4` gives us all the relocations of the binary:
```C
Relocation section '.rel.dyn' at offset 0x304 contains 2 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
080496fc  00000106 R_386_GLOB_DAT    00000000   __gmon_start__
08049730  00000905 R_386_COPY        08049730   stdin

Relocation section '.rel.plt' at offset 0x314 contains 7 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0804970c  00000107 R_386_JUMP_SLOT   00000000   __gmon_start__
08049710  00000207 R_386_JUMP_SLOT   00000000   fgets
08049714  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main
08049718  00000407 R_386_JUMP_SLOT   00000000   _exit
0804971c  00000507 R_386_JUMP_SLOT   00000000   printf
08049720  00000607 R_386_JUMP_SLOT   00000000   puts
08049724  00000707 R_386_JUMP_SLOT   00000000   exit
```
`R_386_JUMP_SLOT` - The content of the specified address contains the address for a jump instruction. For instance, for the symbol `exit`, the address `0x08049724` contains:

* Before the resolving, the address to the code which will perform the resolve and will then invoke `exit`
* After the resolving, the address of the function `exit`

Also with `readelf --section-headers ./format4` we can get the address, offset and size of interesting sections:
```C
There are 32 section headers, starting at offset 0x4f9c:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [10] .rel.dyn          REL             08048304 000304 000010 08   A  6   0  4
  [11] .rel.plt          REL             08048314 000314 000038 08   A  6  13  4
  [13] .plt              PROGBITS        0804837c 00037c 000080 04  AX  0   0  4
  [22] .got              PROGBITS        080496fc 0006fc 000004 04  WA  0   0  4
  [23] .got.plt          PROGBITS        08049700 000700 000028 04  WA  0   0  4
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

```

## Sections Explained

* `.got` <br/>
This is the Global Offset Table (GOT). This is the actual table of offsets as filled in by the linker for external symbols.
* `.plt` <br/>
This is the Procedure Linkage Table (PLT). These are stubs that look up the addresses in the .got.plt section, and either jump to the right address, or trigger the code in the linker to look up the address. (If the address has not been filled in to .got.plt yet.)
  * A neat way to view all function stubs in the PLT section in GDB is by running the command<br/>
    `(gdb) info functions @plt`
* `.got.plt` <br/>
This is the GOT for the PLT. It contains the target addresses (after they have been looked up) or an address back in the .plt stub to trigger the lookup. Classically, this data was part of the .got section.


## Lazy Binding

Code does not call an external function directly, but only via a PLT <i>stub</i>. The linker performs <i><u>lazy binding</u></i> â€” by convention when the dynamic linker loads a library, it will put an identifier and resolution function into known places in the GOT. Therefore, what happens is roughly this: on the first call of a function, it falls through to call the default stub, which loads the identifier and calls into the dynamic linker, which at that point has enough information to figure out "hey, this binary is trying to find the function `printf`". It will go ahead and find it, and then patch the address into the GOT such that the next time the original PLT entry is called, it will load the actual address of the function, rather than the lookup stub. Ingenious!

Let's take a closer look at how the late binding happens in the `format4` binary:
```C
// Dump of assembler code for function vuln:
// ...
0x0804850f <vuln+61>:   call   0x80483ec <exit@plt>

// .plt
// Dump of assembler code for function exit@plt:
// This is a PLT stub function exit
0x080483ec <exit@plt+0>:        jmp    DWORD PTR ds:0x8049724
0x080483f2 <exit@plt+6>:        push   0x30
0x080483f7 <exit@plt+11>:       jmp    0x804837c

/**
* The address seen in the first jump instruction, exit@plt+0, 0x8049724 belongs to the .got.plt section as explained above! This jump will either take us to the exit function (if symbol has been resolved previously) or back to the .plt section
*/

```

```C
/**
* Let's examine the first instruction: 
* 0x080483ec <exit@plt+0>:  jmp    DWORD PTR ds:0x8049724
*
* On the first call of exit@plt,
* (gdb) x/1dwx 0x8049724
* 0x8049724 <_GLOBAL_OFFSET_TABLE_+36>:   0x080483f2
* Which is the next instruction, exit@plt+6 !
*
* The instruction 0x080483f2 <exit@plt+6>:  push 0x30
* is used to inform the dynamic linker about which symbol is to be resolved. Different stubs have different push values
*
* Now lets look at the third instruction:
* 0x080483f7 <exit@plt+11>:  jmp 0x804837c, and find out where it
* jumps to. The jump address is the same for all PLT stubs.
*/

// Start of .plt
0x804837c:      push   DWORD PTR ds:0x8049704
0x8048382:      jmp    DWORD PTR ds:0x8049708
0x8048388:      add    BYTE PTR [eax],al
0x804838a:      add    BYTE PTR [eax],al

/**
* Explanation:
* 0x804837c:      push   DWORD PTR ds:0x8049704
* (gdb) x/1dwx 0x8049704
* 0x8049704 <_GLOBAL_OFFSET_TABLE_+4>:    0xb7fff8f8
* (gdb) info proc map
* ...
* 0xb7fff000 0xb8000000     0x1000    0x1b000         /lib/ld-2.11.2.so
* ...
* So this is some value that belongs to the linker
*
* 0x8048382:      jmp    DWORD PTR ds:0x8049708
* (gdb) x/1dwx 0x8049708
* 0x8049708 <_GLOBAL_OFFSET_TABLE_+8>:    0xb7ff6200
* (gdb) info symbol 0xb7ff6200
* _dl_runtime_resolve in section .text of /lib/ld-linux.so.2
* So what happens here, is that we invoked the function
* _dl_runtime_resolve from the linker in order to resolve the address of exit!
*/
```

```C
/**
* Let's examine again the first instruction of the PLT stub: 
* 0x080483ec <exit@plt+0>:  jmp    DWORD PTR ds:0x8049724
* 
* On the second (and further) calls of exit@plt,
* (gdb) x/1dwx 0x8049724
* 0x8049724 <_GLOBAL_OFFSET_TABLE_+36>:   0xb7ec60c0
* (gdb) info symbol 0xb7ec60c0
* exit in section .text of /lib/libc.so.6
* Which is the address of the exit libc function!
* The rest of the stub (exit@plt+6 and further on) is not called any more
*/
```

