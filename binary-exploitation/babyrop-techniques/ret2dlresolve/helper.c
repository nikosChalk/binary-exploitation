
//https://github.com/google/bloaty/blob/master/third_party/freebsd_elf/elf64.h
#include <stdlib.h>
#include <stdint.h>

typedef uint64_t Elf64_Addr  ;
typedef uint64_t Elf64_Xword ;
typedef int64_t  Elf64_Sxword;

typedef struct elf64_rela {
   Elf64_Addr r_offset    ;   // Address in GOT table. Location to apply the relocation action
   Elf64_Xword r_info     ;   // The symbol table index (ELF64_R_SYM) and the type of relocation (ELF64_R_TYPE). | ELF64_R_SYM (32-bit) | ELF64_R_TYPE (32-bit) |
                              // symbol table resides in .symtab section
   Elf64_Sxword r_addend  ;   // A constant addend used to compute the relocatable field value. We want it 0 for the exploit.

} Elf64_Rela; //struct is 24 bytes in size
#define ELF64_R_SYM(info)             ((info)>>32)
#define ELF64_R_TYPE(info)	((info) & 0xffffffff)

typedef uint32_t Elf64_Word;
typedef struct elf64_Sym {
	Elf64_Word	st_name;	  // Offset in .dynstr section that points to the name of the symbol.
  /* ... */
  
} Elf64_Sym; //struct is 24 bytes in size

// call of unresolved write(0, buf, 0x100)
_dl_runtime_resolve(link_map, rel_offset) {
    //From the index `rel_offset` in the Relocation table (.rela.plt), extract the name of the symbol that needs to be resolved (e.g. "write")

    Elf64_Rela *rel_entry = JMPREL + rel_offset;  //kinda like metadata for .got.plt entries.
    Elf64_Sym *sym_entry = SYMTAB[ ELF64_R_SYM(rel_entry->r_info) ]; //lookup symbol in symbol table. ACCESS MUST BE ALIGNED to 24-byte boundary (24 bytes == sizeof(Elf64_Sym)).

    char *sym_name = STRTAB + sym_entry->st_name;
    _search_for_symbol_(link_map, sym_name); // Works kinda like dlsym()

    // invoke initial write call now that symbol is resolved
    write(0, buf, 0x100);
}
