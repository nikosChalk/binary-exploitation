

## How to inject payloads
https://reverseengineering.stackexchange.com/questions/13928/managing-inputs-for-payload-injection

A website that offers various shellcodes can be found here: http://shell-storm.org/shellcode/ 

## Why my buffer overflow exploit opens a user shell instead of root shell?
The answer and reasons can be found here https://stackoverflow.com/questions/46778979/why-will-my-buffer-overflow-exploit-open-a-user-shell-only-instead-of-a-root-she

### An overveiw
```bash
(gdb) run < ./mycommands.txt # Redirect stdin to input file
(gdb) run < <(python -c 'print("\xef\xbe\xad\xde")') # Redirect input using bash's process substition
(gdb) run <<< $(python -c 'print("\xef\xbe\xad\xde")') # DO *NOT* *NOT* USE. This last technique filters out all NULL bytes 
```
### How process substition works:
`./foo < <(echo "foo")`<br/>
bash substitutes `<(echo "foo")` with something like `/dev/fd/123`, which is a file descriptor of the stdout of `echo`. We can use that fd similarly to a FIFO special file ("named pipe") and read from that FIFO.<br/>
See here: https://stackoverflow.com/questions/1456253/gdb-debugging-with-pipe

TL;DR: Sections starting with `.plt` (e.g. `.plt.gets` or as more commonly seen `gets@plt`) contain stubs to jump to the target external function. Sections starting with `.got` (e.g. `.got.plt`) are tables of the target addresses

## GOT and PLT
An explanation of how the Global Offset Table (GOT) and the Procedure Linkage Table (plt) can be exploted.
https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html 

## objdump
Common Flags for display options
* --disassembler-option=intel-mnemonic Select Intel flavor
* --prefix-addresses More verbose addresses (gdb style)
* -h, --[section-]headers  Display the contents of the section headers

Common Flags for disassembly options
* -d, --disassemble   Display assembler contents of executable sections
* -t, --syms          Display the contents of the symbol table(s)
    * The most commond format for ELF files looks like this:<br/>
    ```
    00000000 l    d  .bss   00000000 .bss
    00000000 g       .text  00000000 fred
    ```
    1. The first number is the symbol's address
    2. The next field is actually a set of characters indicating the flag bits that are set on the symbol.
    3. Next is the section with which the symbol is associated or `ABS` if the section is absolute (i.e. not connected with any section), or `UND` if the section is referenced in the file being dumped, but not defined there (undefined).
    4. After the section name comes another field, a number, which for common symbols is the alignment and for other symbol is the size.
    5. Finally the symbol's name is displayed.
    * `$ man objump` for more
* Dumping GOT and PLT: `$ objdump -d --full-contents -j .plt -j .got.plt`

## Examining process memory mapping
`$ cat /proc/PID/maps` - Displays also protection bits for the memory sections (rwx). Note that `PID` is the process ID of the process that you want to examine, <u>NOT</u> the PID of gdb! <br/>
`(gdb) info mappings` - However, it does not display protection bits for the sections.