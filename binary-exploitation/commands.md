

## How to inject payloads
https://reverseengineering.stackexchange.com/questions/13928/managing-inputs-for-payload-injection

A website that offers various shellcodes can be found here: http://shell-storm.org/shellcode/ 

## Why my buffer overflow exploit opens a user shell instead of root shell?
The answer and reasons can be found here https://stackoverflow.com/questions/46778979/why-will-my-buffer-overflow-exploit-open-a-user-shell-only-instead-of-a-root-she

### An overveiw
```bash
(gdb) run < ./mycommands.txt # Redirect stdin to input file
(gdb) run < <(python -c 'print("\xef\xbe\xad\xde")') # Redirect input using bash's process substition
(gdb) run <<< $(python -c 'print("\xef\xbe\xad\xde")') # DO *NOT* *NOT* USE. This last technique filters out all NULL bytes 
```
### How process substition works:
`./foo < <(echo "foo")`<br/>
bash substitutes `<(echo "foo")` with something like `/dev/fd/123`, which is a file descriptor of the stdout of `echo`. We can use that fd similarly to a FIFO special file ("named pipe") and read from that FIFO.<br/>
See here: https://stackoverflow.com/questions/1456253/gdb-debugging-with-pipe

TL;DR: Sections starting with `.plt` (e.g. `.plt.gets` or as more commonly seen `gets@plt`) contain stubs to jump to the target external function. Sections starting with `.got` (e.g. `.got.plt`) are tables of the target addresses

## GOT and PLT
An explanation of how the Global Offset Table (GOT) and the Procedure Linkage Table (plt) can be exploted.
https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html 

## objdump
Common Flags for display options
* --disassembler-option=intel-mnemonic Select Intel flavor
* --prefix-addresses More verbose addresses (gdb style)
* -h, --[section-]headers  Display the contents of the section headers

Common Flags for disassembly options
* -d, --disassemble   Display assembler contents of executable sections
* -t, --syms          Display the contents of the symbol table(s)
    * The most commond format for ELF files looks like this:<br/>
    ```
    00000000 l    d  .bss   00000000 .bss
    00000000 g       .text  00000000 fred
    ```
    1. The first number is the symbol's address
    2. The next field is actually a set of characters indicating the flag bits that are set on the symbol.
    3. Next is the section with which the symbol is associated or `ABS` if the section is absolute (i.e. not connected with any section), or `UND` if the section is referenced in the file being dumped, but not defined there (undefined).
    4. After the section name comes another field, a number, which for common symbols is the alignment and for other symbol is the size.
    5. Finally the symbol's name is displayed.
    * `$ man objump` for more
* Dumping GOT and PLT: `$ objdump -d --full-contents -j .plt -j .got.plt`

## Examining process memory mapping
`$ cat /proc/PID/maps` - Displays also protection bits for the memory sections (rwx). Note that `PID` is the process ID of the process that you want to examine, <u>NOT</u> the PID of gdb! <br/>
`(gdb) info mappings` - However, it does not display protection bits for the sections.

As seen in the [man page](https://linux.die.net/man/5/proc):
> "offset" is the offset into the file/whatever, "dev" is the device (major:minor), and "inode" is the inode on that device. 0 indicates that no inode is associated with the memory region, <b>as the case would be with BSS (uninitialized data). </b>

The BSS segment of executable files isn't stored on disk, because the BSS segment is expected to be zero-initialized when a new process is created. So it is reasonable that the BSS segment is not associated with either a dev, an inode or a pathname. See more in [page 438 of Linux Device Drivers book](https://www.iitg.ac.in/asahu/cs421/books/LDD3e.pdf#page=438&zoom=auto,23,683)

## Disabling ASLR

When exploring a new binary, it is very convenient to temporary disable ASLR so that your GDB breakpoints will stay the same and you can take notes of addresses. Of course your final exploit should deal with ASLR but disabling it helps a lot with the development process and things are less ugly and consistent. You can disable ASLR by running the command:<br/>
`echo 0 | sudo tee /proc/sys/kernel/randomize_va_space`<br/>
This will not persist through boot. The possible values are:

* `0` – No randomization. Everything is static.
* `1` – Conservative randomization. Shared libraries, stack, `mmap()`, vDSO (virtual Dynamic Shared Object) and heap are randomized.
* `2` – Full randomization. In addition to elements listed in the previous point, memory managed through `brk()` is also randomized.

More info [here](https://askubuntu.com/questions/318315/how-can-i-temporarily-disable-aslr-address-space-layout-randomization/318476#318476) if you would like to persist through boot.
