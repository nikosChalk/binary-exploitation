
# Reversing Binaries

## Assets

1. [Ghidra CheatSheet](https://ghidra-sre.org/CheatSheet.html)
2. [Improving Disassembly and Decompilation in Ghidra](https://ghidra.re/courses/GhidraClass/Advanced/improvingDisassemblyAndDecompilation.pdf)

## General

`strace` – Runs a given program and traces system calls and signals.<br/>
Flags:
* `-f` &nbsp; Follows forks
* Example: `strace ./a.out`

`cat /etc/passwd` – This will effectively print the users' username, uid, and guid.

`netstat` – A tool for printing processes that consume network resources (e.g. ports, interfaces, etc.) Some common commands are:<br/>
* `netstat -plant`
    * `-p` &nbsp; Shows the processe's `PID`
    * `-l` &nbsp; Shows only the sockets in `LISTEN` state
    * `-a` &nbsp; Shows all sockets that are either in `LISTEN` state or not
    * `-n` &nbsp; Show numerical addresses instead of trying to determine symbolic host, port or user names.
    * `-t` &nbsp; Shows only TCP sockets

    If the output column `PID/Program name` is empty, then you need to run the command wwith `sudo`.

# Binary Reversing


## Stack smashing protection in 32bit x86 Linux systems

[This](http://web.archive.org/web/20171209132837/https://www.software-architect.net/blog/article/date/2015/03/31/the-gs-segment-and-stack-smashing-protection-1.html) is the pattern encountered when stack smashing has been enabled by gcc. A quick overview of the pattern is shown bellow:

```asm
# Intel syntax is used

f:   # code for function f()
; Set up the stack
        push   ebp
        mov    esp, ebp
        and    esp, -0x10   # 8-byte stack alignment
        sub    esp, 0x20     # stack allocation

; Set up stack guard
        mov    eax, gs:0x14,       ; load random value
        mov    DWORD PTR [esp+x], eax     ; store value as a guard variable. # x can be any constant offset
        xor    eax, eax         ; make sure that noone can read the random value afterwards. Effectively sets eax to 0.
;...
; strcpy ommitted (this overwrites 12(%esp) since the string is too large for the buffer)
;...

; Check stack guard against value from TCB (Thread Control Block)
        mov    edx, DWORD PTR [esp+x] ; load previously stored value from stack
        xor    edx, DWORD PTR gs:0x14 ; check if still the same
        je      .L3                ; yes, then fine
        call    __stack_chk_fail   ; print error message and abort()
.L3:
        leave
        ret
```

## How to determine stack size (32bit) of a function frame

1. Disassemble the function and find where it normally returns. The return pattern is something like:

    ```asm
    (gdb) disassemble validate_credentials 
    Dump of assembler code for function validate_credentials:
    0xb7ffe2af <+351>:   add    esp,0x84c
    0xb7ffe2b5 <+357>:   pop    ebx
    0xb7ffe2b6 <+358>:   pop    esi
    0xb7ffe2b7 <+359>:   pop    edi
    0xb7ffe2b8 <+360>:   pop    ebp
    0xb7ffe2b9 <+361>:   ret
    ```

2. We will assume that the stack frame starts from the saved return address (inclusive) and upwards. So the stack looks like:

    ```asm
    gHidra Offset       Value           Address/Comment
                    |---------------|   0x00000000
                    |   ......      |
                    +---------------+
                    |   local_f2M   |   <-- $esp
                    |   ......      |
       -0x08        |   local_f21   |   function f2 stackframe
       -0x04        |   old_ebp     |   <-- $f2_old_ebp
        0x00        |   ret_addr    |   <-- gHidra's Stack[0x00] == $f2_ra
                    +---------------+
        0x04        |   arg1        |
                    |   ...         |
        0x04*N      |   argN        |   function f1 stackframe
                    |   ...         |
                    |   local_f1K   |
                    |   ...         |
                    +---------------+
                    |   ...         |
                    |_______________|   0xffffffff
    ```

3. The stack frame size for `f2` is: `0x84c + 4*5` because we have `0x84c` for locals, 4 saved registers and the saved `$eip`. So, in order to set a pointer to the start of the stack frame of function `f2` all we have to do is:<br/>
Hit breakpoing at: `==> 0xb7ffe2af <+351>:   add    esp,0x84c` so that we have setup `$esp` correctly. Then: <br/>
`(gdb) set $f2_ra = $esp+0x84c+16`<br/>
`(gdb) set $f2_old_ebp = $esp+0x84c+12`
