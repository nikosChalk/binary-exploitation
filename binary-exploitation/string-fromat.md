

# String Format vulnerabilities
These vulnerabilities are found with the `printf(const char *format, ...)` function, when the attacker controls the first (`format`) parameter. So the attacker can any specifier that is expected by `printf` such as `%d`.

You can also do `man printf` and look at the "BUGS" section, at the bottom of the man page.

These vulnerabilities are categorized as:
* <u>Memory leak vulnerabilities</u>, as the attacker can use specifiers such as `%x` to dump the whole stack! If the stack contains pointers, he has successfully leaked memory addresses and he should be able to defeat ASLR. Also stack canaries can be leaked!


## Specifier `%n`
As written in the man page 
> The number of characters written so far is stored into the integer pointed to by the corresponding argument. That argument shall be an `int*`, or variant whose size matches the (optionally) supplied integer length modifier. No argument is converted. <br/>
(This specifier is not supported by the bionic C library.) The behavior is undefined if the conversion specification includes any flags, a field width, or a precision.

So when we use `%n` we are able to write in an arbitrary memory area! How do we do that? Well, the `format` parameter will contain our target address e.g. `\x38\x96\x04\x08` (mind the endianess!) and we must find

Furthermore, notice that the man page states:
>  That argument shall be an int*, or variant whose size matches the (optionally) supplied integer length modifier.

This means that we can write:
* `int` with the simple `%n`
* `unsigned short int` with `%hn`
* `unsigned char` with `%hhn`
* `long int` with `%ln`
* `long long int` with `%lln`


## Dollar (`$`) formatting
Taken from the man page of printf
> One can also specify explicitly which argument is taken, at each place where an argument is required, by writing `%m$` instead of `%`, where the decimal integer `m` denotes the position in the argument list of the desired argument, indexed starting from 1.

So, `printf("%d %d", width, num)` is equivalent to `printf("%1$d %2$d")`. Since the variadic arguments are on the stack, we can dump whichever stack value we want by providing the correct `m` and using the correct specifier (e.g. `d`, `x`, `c`, etc.)

## Neat trick when writing with string format vulnerabilities
It is a good idea to keep the formatted string the same length across executions so the values on stack do not change addresses. This python function will allow you to write exploits that always have the same length
```python
#!/usr/bin/python2.6
def pad(s, length=500):
    return (s+"A"*length)[:length]

print(pad("Hello World!")) # Example usage
```
