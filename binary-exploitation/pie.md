# Position Independent Code (PIE)

## Connection between ASLR and PIE

If you disable ASLR, but the binary is PIE-enabled, then the binary will not be loaded at base address `0x08048000` but instead to a random one (e.g. `0x56555000`). However, that random base address will be the same between different invocations of the binary. Only when both ASLR and PIE are enabled simultaneously, then to base address of the binary will be relocated on each execution.

## 32bit PIE (Position Independent Code)

### `.plt` section

Function stubs use the `ebx` register in order to resolve the base address for the `.got.plt` section.

```asm
# .plt section with function stubs

# Function stub for fork()
0xb7ffcfd0 <fork@plt>:       jmp    DWORD PTR [ebx+0xd0]    # fork@got.plt
0xb7ffcfd6 <fork@plt+6>:     push   0x188
0xb7ffcfdb <fork@plt+11>:    jmp    0xb7ffccb0

# Function stub for listen()
0xb7ffcfe0 <listen@plt>:     jmp    DWORD PTR [ebx+0xd4]    # listen@got.plt
0xb7ffcfe6 <listen@plt+6>:   push   0x190
0xb7ffcfeb <listen@plt+11>:  jmp    0xb7ffccb0
``` 

According to [stackoverflow](https://stackoverflow.com/questions/41811353/why-is-ebx-saved-in-the-stack-frame-of-a-simple-function-calling-gets/41811625#41811625):

> On 32-bit x86, in order for position-independent code to call functions that may reside in a different library from the caller, the address of the calling module's GOT must be loaded into `ebx` at call time; this is an ABI requirement. Since `ebx` is a call-saved register in the x86 ABI, the caller must save and later restore it before returning to its own caller.

Furthermore, if the binary has stack canaries enabled, the `ebx` register is stored after (bellow) the canary, just like all the callee saved registers.

### How function stubs in `.plt` section are invoked

Let's examine the following code from a `webserver()` function that invokes the libc function `fgets()`:

```asm
=> 0xb78a33fd <webserver+269>:  call   0xb78a1d50 <fgets@plt>
   0xb78a3402 <webserver+274>:  test   eax,eax

(gdb) x/5bx 0xb78a33fd
0xb78a33fd <webserver+269>:     0xe8    0x4e    0xe9    0xff    0xff
```

So, according to the [x86 manual](https://c9x.me/x86/html/file_module_x86_id_26.html) this is a `CALL rel32` instruction with displacement relative to next instruction. The offset for the call, relative to next instruction, is:

```asm
(gdb) x/1wx 0xb78a33fd+1
0xb78a33fe <webserver+270>:     0xffffe94e # offset relative to next instruction
```

So the jump target (32bit unsigned integer) is calculated as:<br/>
`0xb78a3402 + 0xffffe94e == 0xb78a1d50 <fgets@plt>:      jmp    DWORD PTR [ebx+0x30]`

## 64bit PIE (Position Independent Code)

TODO

To review:
1. [return-to-csu attack](https://i.blackhat.com/briefings/asia/2018/asia-18-Marco-return-to-csu-a-new-method-to-bypass-the-64-bit-Linux-ASLR-wp.pdf) (A method to bypass 64-bit Linux ASLR)
