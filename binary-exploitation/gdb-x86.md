
# GDB

Bellow is a list of some handy invocations of gdb:

* `gdb -p <PID>` - Attaches GDB to an already existing running process
    * A neat way to invoke GDB in this way is with the help of `pidof` command, e.g.:<br/>
    `gdb -p $(pidof final0)`

Bellow is a list of commonly used commands in the `(gdb)` prompt

* `echo <string>` - Displays the given string. Useful when setting commands for breakpoints. No newline is printed by default (use "\n" if you want a new line)
* `set disassembly-flavor intel`
* `set follow-fork-mode child` - This tells gdb to follow children processes when debugging
* `set $<var_name> = expression` - Creates a variable in the GDB, which is known as the "watch" feature in GUI debuggers.
    - example: `set $auth_tracker = auth`, where `auth` is a variable of pointer to a struct in the program. Then we can also print the contents of the struct in a smart way: `p *$auth_tracker` or `p *auth`
* `init-if-undefined $<var_name> = expression` -  Set a convenience variable if it has not already been set. If the variable is already defined then the expression is not evaluated so any side-effects do not occur.
    - This is useful when running commands in `define hook-stop` which require some prior variable to have been set. (`hook-stop` is ran before the a breakpoint's code)
* `file <program>` - Specifies the the given program is to be debugged and loads its symbols.
    * This is useful when developing exploits that attempt to take over the system, since these exploits usually use `execve()`, `system("/bin/sh")` or any other similar function that overwrites the processes image. With this gdb command, we can restore the program's original image.
* `dissasemble <addr>` - From the given address, searches upwards the address space to find the nearest symbol (e.g. function) to start disassembling from. Essentially, it will disassemble the function that contains the given code address.
* `info proc mappings` - Displays info about the layout of the binary (stack, heap, etc.)
* `info frame` - Display info about the current stack frame
* `info args`  - Display info about the arguments to the current function
* `info locals`- Display info about the local variables in this stack frame
* `info registers` - Dump registers
* `info addr <variable>` - Displays the offset of the variable in the stack frame
* `info symbol <addr>` - Print the name of a symbol which is stored at the address `addr`. If no symbol is stored exactly at `addr`, gdb prints the nearest symbol and an offset from it
* `info functions [REGEXP]` - Lists all function names, or those matching `REGEXP`.
    * For example, `(gdb) info functions @plt` will list all function stubs in the PLT section
* `print 'gets@plt'` - For printing symbols defined at sections
* `find start-address, end-address, expr1 [, expr2 ...]`</br>
    `find start-address, +length, expr1 [, expr2 ...]` </br>
    These commands will search for the specified expression in the given address space. For example, in order search the string "/bin/sh" we can type `info proc map` to get the addresses where libc resides and then type: `find 0xb7e97000, 0xb7fd9000-1, "/bin/sh"`
    * In case of error "warning: Unable to access target memory at 0xYYYYYYYY , halting search." just see this [question here](https://stackoverflow.com/questions/34819167/gdb-find-command-error-warning-unable-to-access-x-bytes-of-target-memory-at-y)
* `define hook-stop` - Define what to happen whenever we hit a breakpoint (e.g. print registers, stack content, etc.). Typing `end` ends the command list and returns to the gdb prompt.
* `command [breakpoint nr]` - Define which commands to be executed when we hit the specified breakpoint. If no breakpoint is specified, then the last set breakpoint is assumed. Typing `end` ends the command list and returns to the gdb prompt.
    - When printing a lot of stuff when breakpoints are hit, it might be useful to turn `pagination` off
* `pagination` - Certain commands to GDB may produce large amounts of information output to the screen. To help you read all of it, GDB pauses and asks you for input at the end of each page of output. Type `RET` when you want to see one more page of output, `q` to discard the remaining output, or `c` to continue without paging for the rest of the current command.
    - `set pagination on/off` Toggles the pagination behavior
* Running a program with non-printable command line arguments<br/>
`run $(python -c "print('\xde\xad\xbe\xaf')")` to run it with 0xdeafbeaf

## Examining stack contents
```gdb
(gdb) bt          # Print the stack with the called functions
(gdb) info frame  # Print info about the current stack frame
(gdb) x/100x $esp # Examine content of stack frame (e.g. locals)
```
* You can move arround the stack frames with `up <count>` and `down <count>` commands

# x86 Architecture

## Intel vs AT&T syntax
* `add eax, ebx` <=> `eax <-- eax + ebx` (Intel syntax)
* Register names in AT&T syntax are prefixed with `%`, and the order is swapped

## Addressing Modes
Here we illustrate some examples using the `mov` instruction that moves data between registers and memory
```assembly
mov eax, [ebx]          ; Move the 4 bytes in memory at the address contained in EBX into EAX
mov [var], ebx          ; Move the contents of EBX into the 4 bytes at memory address var. (Note, var is a 32-bit constant).
mov eax, [esi-4]        ; Move 4 bytes at memory address ESI + (-4) into EAX
mov [esi+eax], cl       ; Move the contents of CL into the byte at address ESI+EAX
mov edx, [esi+4*ebx]    ; Move the 4 bytes of data at address ESI+4*EBX into EDX
```

## Size Directives
In some cases the size of a referred-to memory region is ambiguous. Consider the instruction `mov [ebx], 2`. Should this instruction move the value 2 into the single byte at address `ebx`? Perhaps it should move the 32-bit integer representation of 2 into the 4-bytes starting at address `ebx`. Since either is a valid possible interpretation, the assembler must be explicitly directed as to which is correct. For example: `mov WORD PTR [ebx], 2` - Move the 16-bit integer representation of 2 into the 2 bytes starting at the address in `ebx`. <br/>
The various size directives are:
* `BYTE PTR` - 1 Byte = 8 bits
* `WORD PTR` - 2 Byte = 16 bits
* `DWORD PTR` - 4 Byte = 32 bits
* `QWORD PTR` - 8 Byte = 64 bits

## Registers
* `ebp` - Base Pointer. Contains an address, pointing to the bottom-most valid stack element of the current stack frame
* `esp` - Stack Pointer. Contains an address, pointing to the top-most valid stack element of the current stack frame
    * A common command that you might see with this register is `and esp, 0xffffff0` in order to align `esp` in a 4-Byte address
* `eip` - Instruction Pointer.

## Instructioms

### Function calls
* `leave` - { esp <-- ebp; pop ebp } 
* `call` - Invoke function
    1. Push the address of the next instruction (next instruction = The instruction after the current value of `eip`. In our case `eip` points to `call`). This effectively increases `esp` to point to the new pushed value.
    2. Jump to the target address

### General
* `mov DWORD PTR[esp+0x5c], 0x0` is equivalent to `*(esp+0x5c) <-- (i32)0x0`
* `lea <reg32>,<mem>` - Load Effective Address. Similar to `mov`, but instead places the address specified by its second operand into the register specified by its first operand. Note, the contents of the memory location are not loaded.
    * e.g. `lea eax, [esp+0x1c]` is equivalent to `eax <-- esp+0x1c`

### `LEA` vs `MOV`
* `LEA` means Load Effective Address
* `MOV` means Load Value

In short, `LEA` loads a pointer to the item you're addressing whereas `MOV` loads the actual value at that address.
```assembly
LEA eax, [EBP+ESI+5] ; Compute address of value
MOV eax, [EBP+ESI+5] ; Load value at that address
```

### Comparisons
* `test` - Sets the zero flag `ZF` when the result of the AND operation is zero. Also sets the sign flag `SF` when the most significant bit is set in the result and the parity flag `PF` when the number of set bits is even.
* `cmp` - Subtracts the operands and sets the flags. Namely, it sets the zero flag `ZF` if the difference is zero (operands are equal).

## Function call conventions

### Stack Frame
`Stack Fame` - Is the area of memory between `ebp` and `esp`, including the addresses pointed by both. Note that the address to return after the function has ended, is <u>outside</u> of the stack frame.

```assembly
; Caller
call main       ; Push return address and jump

; Callee
push ebp        ; Save old ebp
move ebp, esp   ; Change ebp to point to the base of the new stack frame
and esp, 0xffffff0  ; Align esp to a 2-byte address
; Allocate stack space by decreasing the value of esp 
; ...
; De-allocated stack space by increasing the value of esp
leave           ; esp <-- ebp, which effectively destroys the stack frame.
                ; pop ebp, which restores ebp to its old value and decreases
                ; esp. Now we the previous stack frame is active.
ret             ; Pop an element from the stack and store it in eip. This
                ; will decrease esp and return to the Caller
```
<b><u>Note</u></b>: The compiler may allocate more stack space than the function might actually need. This is usually called padding. It may be done for alignment reasons.

### Function call Arguments
Function arguments are passed in Right-to-Left order. This is true for all the C function call conventions: CDECL (`_cdecl`), STDCALL (`_stdcall`) and FASTCALL (`_fastcall`). Right-to-Left order is also used in C++ function call convention, THISCALL (`_thiscall`).<br/>
In general, the <b>Right-to-Left</b> convention is followed.

Let us examine this convention through an example. <br/>
Assume the following C function call
```C
void MyFunction2(int x, int y, int z);

MyFunction2(10, 5, 2);
```
This will produce the following assembly code
```assembly
push 2
push 5
push 10
call _MyFunction2
```

The stack during the execution of `MyFunction2` will look like this:
```
      0x00000000
        :    :
esp --> |    | [ebp - X] = [esp] # Top-most valid elemnt of the stack frame
        :    : 
        |    | [ebp - 8] # 2nd local variable
        |    | [ebp - 4] # 1st local variable
ebp --> | FP | [ebp]     # Old ebp value
        | RA | [ebp + 4] # Address to return after MyFunction2 has finished
        | 10 | [ebp + 8]  # 1st argument - x
        | 5  | [ebp + 12] # 2nd argument - y
        | 2  | [ebp + 16] # 3st argument - z
        :    : 
      0xffffffff
```


# FAQ

## BufferOverflow works in GDB but not without it
Here is the explanation https://stackoverflow.com/questions/17775186/buffer-overflow-works-in-gdb-but-not-without-it/17775966#17775966