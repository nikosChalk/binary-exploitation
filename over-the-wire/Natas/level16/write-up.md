# Write up

To login in the domain `http://natas16.natas.labs.overthewire.org` use credentials:

Username: `natas16`<br/>
Password: `WaIHEacj63wnNIBROHeqi3p9t0m5nhmh`

This challenge is quite similar to a previous challenge natas10, however more restrictions apply here. By examining the source code, we observe that the following characters are illegal: `;` `|` `&` `` ` `` `'` `"`.<br/>
In addition, the command to be executed is: `grep -i "<key>" dictionary.txt"` 

These restrictions means that:

* We cannot pipe commands together with `|`
* We cannot chain commands together, e.g. with `;` or `&&` or even with `||`
* We cannot change the arguments of `grep` like we did in natas10, since we cannot enter double quotes

However, the characters `$` `(` `)` `<` `>` `\` `/` are not escaped and are considered valid. This means that:

* With the character `/` we can traverse paths
* With the character `\` we can perform escapes
* [Command substitution](https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html) `$(command)` is allowed
* [Process substitution](https://tldp.org/LDP/abs/html/process-sub.html) `<(command)` is allowed
* [Here document](https://bash.cyberciti.biz/guide/Here_documents) `command <<HERE`<br/>`text1`<br/>`text2`<br/>`HERE`<br/> is allowed, although not very useful
* [Here-string](https://bash.cyberciti.biz/guide/Here_strings) `command <<< "text"` is allowed
* Input/Output (e.g. `2>/dev/null` redirection is allowed

Now, which commands could prove useful to us as primitives in order to leak data?

* Check if a file starts with a prefix: `grep -e ^prefix file.txt`
* Read arbitrary `N` bytes from file at offset `X` : `dd if=file.txt bs=1 count=N skip=X`
* Print character in octal format `printf %b \\110`


## Failed attempt #1

So the initial idea was this:

1. Read the `i`-th character from the file `/etc/natas_webpass/natas17`, which contains the password.
2. Compare it with a character given from input
3. Check if we match it based on the response from the server.

So in order to implement reading the `i`-th character from the password file we use the command<br/>
`dd if=/etc/natas_webpass/natas17 bs=1 count=1 skip=i`<br/>
Then, we can use the `test` shell built-in ([more info here](https://unix.stackexchange.com/questions/99185/what-do-square-brackets-mean-without-the-if-on-the-left/99186#99186) or type `help [` in bash) in order to compare that character with an arbitrary character (e.g. `a` given by us in the input.<br/>
`[ a = $(dd if=/etc/natas_webpass/natas17 bs=1 count=1 skip=i) ]`<br/>
However this command outputs nothing and the result is stored as exit status code with `0` indicating true and `1` indicating false. So we use the [exit status special variable](https://www.tldp.org/LDP/abs/html/special-chars.html) `$?` in order to retrieve the result and print it.<br/>
`echo $([ a = $(dd if=/etc/natas_webpass/natas17 bs=1 count=1 skip=i) ]) $?`<br/>
Since the `dictionary.txt` file in the server does not contain any numbers (simply entering any number in the search filed will yield zero results), we have to convert this value into a printable ASCII character.

We need to be a little bit creative here. One niche way to do this is to append the `echo`'ed value (`0` or `1`) to the string `11`. This results in either in the string `110` or `111`. Now, if we interpert these values as octal numbers they represent the characters `H` and `I` respectively. In other words

```bash
printf %b \\110
H

printf %b \\111
I
```

So finally we have the command:<br/>
`printf %b \\11$(echo $([ a = $(dd if=/etc/natas_webpass/natas17 bs=1 count=1 skip=i) ]) $?)`<br/>
which outputs `H` if our testing condition is true or `I` otherwise. Now the server responds with different outputs if we input `H` and `I` separately in the input field. Thus our final input is:<br/>
`$(printf %b \\11$(echo $([ a = $(dd if=/etc/natas_webpass/natas17 bs=1 count=1 skip=i) ]) $?))`<br/>
and the command that the server will execute will be

```bash
grep -i "$(printf %b \\11$(echo $([ a = $(dd if=/etc/natas_webpass/natas17 bs=1 count=1 skip=i) ]) $?))" dictionary.txt
```

Running a few test cases, we observe that no matter what the brute-forced character, we always get the "`H`" page which evaluates to false. Huh? Why? Well it probably has to do with the shell that the commands are executed on, i.e. `bash` or `sh`.

Let's execute <u>locally</u> the command `echo $([ q = $(dd if=dictionary.txt bs=1 count=1 skip=0) ]) $?` which we know that it must evaluate to false, since the first character in the dictionary is `A`. (We can get the whole dictionary by entering `.*` in the input)

* In bash, the command gives the result `1`
* In sh, the command gives the result `0`

Damn, we hit a roadblock here! Let's see if any other features do not work as expected or are disabled. First of all, as ground truth we know that the command `$(dd if=/etc/natas_webpass/natas17 bs=1 count=1 skip=1)` works since we get a portion of the file as output output.

* `$(dd bs=1 count=1 skip=1 if=<(cat dictionary.txt))` did not work on target since we got empty output. Thus we can infer that <u>process substitution</u> `<(command)` <u>does not work.</u>
* `$(dd bs=1 count=1 skip=1 <<< text)` did not work on target since we got empty output. Thus we can infer that <u>here-string substitution does not work.</u>
* `$(printf \\x41)` did not work on target since we got empty output. 
* `$(printf %b \\110)` however did work.

These are commands that work in bash but not in sh. So probably the commands are run in an sh shell.

## Successful Attempt #2

After the frustration and all the trial and error in the first attempt, we approach the problem with the above considerations in mind. First of all the command <br/>
`$(dd if=/etc/natas_webpass/natas17 bs=1 count=1 skip=1)`
works. So when the is given that input it will execute<br/>
`grep -i "$(dd if=/etc/natas_webpass/natas17 bs=1 count=1 skip=1)" dictionary.txt`<br/>

* The dictionary does not contain numbers
* The search is case-insensitive
* The length of the output is different for each character (case-insensitive again) and for numbers
* No search of a single password character `[a-zA-Z0-9]` yields the whole dictionary as output

Thus with the above in mind, by executing the above command, based on the output length, we can infer whether a password character at a given position is a digit or a specific character either lower case or upper case (e.g. `a` or `A`).

Now with this information, for each password character we have either 2 candidates (lower and upper character) or 10 candidates (digits). We can incrementally construct the password by brute-forcing these characters and compare it with the corresponding password prefix stored in `etc/natas_webpass/natas17`. The command <br/>
`$(grep -e ^prefix /etc/natas_webpass/natas17)`<br/>
will output the password if the prefix is found or nothing otherwise.

Thus, if we give the above input to the server, it will execute<br/>
`grep -i "$(grep -e ^prefix /etc/natas_webpass/natas17)" dictionary.txt`<br/>
which will yield nothing if we guessed correct the prefix (since the password is not stored within the dictionary) or the whole dictionary otherwise.

So, implementing that in a python script, we get that the password for natas17 is `8Ps3H0GWbn5rd9S7GmAdgQNdkhPkq9cw`.

So to login in the level17 use the credentials:

Username: `natas17`<br/>
Password: `8Ps3H0GWbn5rd9S7GmAdgQNdkhPkq9cw`
